package src/cmd/ld/* cmd/internal/ld
package src/cmd/6l/* cmd/new6l
package src/cmd/8l/* cmd/new8l
package src/cmd/9l/* cmd/new9l
package src/cmd/5l/* cmd/new5l
package src/liblink/* include/* src/cmd/ld/textflag.h src/runtime/*h internal/libc.h cmd/internal/obj
package src/liblink/*5.c src/cmd/5l/*.out.h cmd/internal/obj/arm
package src/liblink/*6.c src/cmd/6l/*.out.h cmd/internal/obj/x86
package src/liblink/*8.c src/cmd/8l/*.out.h cmd/internal/obj/i386
package src/liblink/*9.c src/cmd/9l/*.out.h cmd/internal/obj/ppc64
package src/liblink/objfilego.c main
package src/cmd/5a/* cmd/new5a
package src/cmd/6a/* cmd/new6a
package src/cmd/8a/* cmd/new8a
package src/cmd/9a/* cmd/new9a
package src/cmd/cc/*body cmd/internal/asm
package src/cmd/gc/* cmd/internal/gc
package src/cmd/5g/* cmd/new5g
package src/cmd/6g/* cmd/new6g
package src/cmd/8g/* cmd/new8g
package src/cmd/9g/* cmd/new9g

delete dnames5 dnames6 dnames8 dnames9
delete emallocz estrdup erealloc

delete find1 nuxiinit fnuxi8 fnuxi4 inuxi1 inuxi2 inuxi4 inuxi8 atolwhex
delete writeobj

# we define our own Biobuf
delete Biobuf

slice LSym.p LSym.np LSym.maxp
slice LSym.r LSym.nr LSym.maxr
slice Link.library Link.libraryp Link.nlibrary
slice Link.libdir Link.nlibdir Link.maxlibdir
slice Arch.typedefs

slice InitPlan.e InitPlan.len InitPlan.cap

bool yy_isalpha.return

ptr bytereg.t
slice doasm.mo

slice Pcdata.p Pcdata.n Pcdata.m

export linkamd64 linkamd64p32 link386 linkarm linkppc64 linkppc64le linknew binitw writeobjdirect linklinehist linknewplist

rename regstr Register
rename anames8 Anames
rename anames6 Anames
rename anames5 Anames
rename anames9 Anames

func Expandpkg(t0 string, pkg string) string {
	return strings.Replace(t0, `"".`, pkg+".", -1)
}

func Symgrow(ctxt *Link, s *LSym, lsiz int64) {
	var siz int
	siz = int(lsiz)
	if int64(siz) != lsiz {
		log.Fatal("Symgrow size %d too long", lsiz)
	}
	if len(s.P) >= siz {
		return
	}
	for cap(s.P) < siz {
		s.P = append(s.P[:cap(s.P)], 0)
	}
	s.P = s.P[:siz]
}

func savedata(ctxt *Link, s *LSym, p *Prog, pn string) {
	off := int32(p.From.Offset)
	siz := int32(p.From3.Offset)
	if off < 0 || siz < 0 || off >= 1<<30 || siz >= 100 {
		mangle(pn)
	}
	if ctxt.Enforce_data_order != 0 && off < int32(len(s.P)) {
		ctxt.Diag("data out of order (already have %d)\n%P", len(s.P), p)
	}
	Symgrow(ctxt, s, int64(off+siz))
	
	switch int(p.To.Type) {
	default:
		ctxt.Diag("bad data: %P", p)

	case TYPE_FCONST:
		switch siz {
		default:
			ctxt.Diag("unexpected %d-byte floating point constant", siz)
		
		case 4:
			flt := math.Float32bits(float32(p.To.U.Dval))
			ctxt.Arch.ByteOrder.PutUint32(s.P[off:], flt)
		
		case 8:
			flt := math.Float64bits(p.To.U.Dval)
			ctxt.Arch.ByteOrder.PutUint64(s.P[off:], flt)
		}

	case TYPE_SCONST:
		copy(s.P[off:off+siz], p.To.U.Sval)
	
	case TYPE_CONST, TYPE_ADDR:
		if p.To.Sym != nil || int(p.To.Type) == TYPE_ADDR {
			r := Addrel(s)
			r.Off = off
			r.Siz = uint8(siz)
			r.Sym = p.To.Sym
			r.Type = R_ADDR
			r.Add = p.To.Offset
			break
		}
		o := p.To.Offset
		switch siz {
		default:
			ctxt.Diag("unexpected %d-byte integer constant", siz)
		case 1:
			s.P[off] = byte(o)
		case 2:
			ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(o))
		case 4:
			ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(o))
		case 8:
			ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(o))
		}
	}	
}

func Addrel(s *LSym) *Reloc {
	s.R = append(s.R, Reloc{})
	return &s.R[len(s.R)-1]
}

export setuintxx

func Setuintxx(ctxt *Link, s *LSym, off int64, v uint64, wid int64) int64 {
	if s.Type == 0 {
		s.Type = SDATA
	}
	s.Reachable = 1
	if s.Size < off+wid {
		s.Size = off + wid
		Symgrow(ctxt, s, s.Size)
	}

	switch wid {
	case 1:
		s.P[off] = uint8(v)
	case 2:
		ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(v))
	case 4:
		ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(v))
	case 8:
		ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(v))
	}
	
	return off+wid
}

diff {
type LinkArch struct {
+	ByteOrder	binary.ByteOrder
}
diff {
type LinkArch struct {
+	Rconv func(int) string
}
diff {
type LinkArch struct {
+	Dconv func(*Prog, int, *Addr) string
}

func addlib(ctxt *Link, src, obj, pathname string) {
	name := path.Clean(pathname)

	// runtime.a -> runtime
	short := strings.TrimSuffix(name, ".a")

	// already loaded?
	for i := range ctxt.Library {
		if ctxt.Library[i].Pkg == short {
			return
		}
	}

	var pname string
	// runtime -> runtime.a for search
	if (!(ctxt.Windows != 0) && name[0] == '/') || (ctxt.Windows != 0 && name[1] == ':') {
		pname = name
	} else {
		// try dot, -L "libdir", and then goroot.
		for _, dir := range ctxt.Libdir {
			pname = dir + "/" + name
			if _, err := os.Stat(pname); !os.IsNotExist(err) {
				break
			}
		}
	}
	pname = path.Clean(pname)

	// runtime.a -> runtime
	pname = strings.TrimSuffix(pname, ".a")

	if ctxt.Debugvlog > 1 && ctxt.Bso != nil {
		fmt.Fprintf(ctxt.Bso, "%5.2f addlib: %s %s pulls in %s\n", Cputime(), obj, src, pname)
	}
	Addlibpath(ctxt, src, obj, pname, name)
}

func Addlibpath(ctxt *Link, srcref, objref, file, pkg string) {
	for _, lib := range ctxt.Library {
		if lib.File == file {
			return
		}
	}
	
	if ctxt.Debugvlog > 1 && ctxt.Bso != nil {
		fmt.Fprintf(ctxt.Bso, "%5.2f addlibpath: srcref: %s objref: %s file: %s pkg: %s\n", Cputime(), srcref, objref, file, pkg)
	}

	ctxt.Library = append(ctxt.Library, Library{
		Objref: objref,
		Srcref: srcref,
		File: file,
		Pkg: pkg,
	})
}

diff {
func Copyp(ctxt *Link, q *Prog) *Prog {
}

export linklinefmt
diff {
-func linklinefmt(ctxt *Link, lno0 int, showAll, showFullPath bool) string {
+func Linklinefmt(ctxt *Link, lno0 int, showAll, showFullPath bool) string {
}

func linklinefmt(ctxt *Link, lno0 int, showAll, showFullPath bool) string {
	var a [HISTSZ]struct {
		incl *Hist
		idel int32
		line *Hist
		ldel int32
	}
	lno := int32(lno0)
	lno1 := lno
	var d int32
	var i int
	var n int
	var h *Hist
	n = 0
	var fp string
	for h = ctxt.Hist; h != nil; h = h.Link {
		if h.Offset < 0 {
			continue
		}
		if lno < h.Line {
			break
		}
		if h.Name != "<pop>" {
			if h.Offset > 0 {
				// #line directive
				if n > 0 && n < int(HISTSZ) {
					a[n-1].line = h
					a[n-1].ldel = h.Line - h.Offset + 1
				}
			} else {
				// beginning of file
				if n < int(HISTSZ) {
					a[n].incl = h
					a[n].idel = h.Line
					a[n].line = nil
				}
				n++
			}
			continue
		}
		n--
		if n > 0 && n < int(HISTSZ) {
			d = h.Line - a[n].incl.Line
			a[n-1].ldel += d
			a[n-1].idel += d
		}
	}
	if n > int(HISTSZ) {
		n = int(HISTSZ)
	}
	for i = n - 1; i >= 0; i-- {
		if i != n-1 {
			if !showAll {
				break
			}
			fp += " "
		}
		if ctxt.Debugline != 0 || showFullPath {
			fp += fmt.Sprintf("%s/", ctxt.Pathname)
		}
		if a[i].line != nil {
			fp += fmt.Sprintf("%s:%d[%s:%d]", a[i].line.Name, lno-a[i].ldel+1, a[i].incl.Name, lno-a[i].idel+1)
		} else {
			fp += fmt.Sprintf("%s:%d", a[i].incl.Name, lno-a[i].idel+1)
		}
		lno = a[i].incl.Line - 1 // now print out start of this file
	}
	if n == 0 {
		fp += fmt.Sprintf("<unknown line number %d %d %d %s>", lno1, ctxt.Hist.Offset, ctxt.Hist.Line, ctxt.Hist.Name)
	}
	return fp
}

func haspathprefix(s string, t string) bool {
	var i int
	var cs int
	var ct int
	if len(t) > len(s) {
		return false
	}
	for i = 0; i < len(t); i++ {
		cs = int(s[i])
		ct = int(t[i])
		if 'A' <= cs && cs <= 'Z' {
			cs += 'a' - 'A'
		}
		if 'A' <= ct && ct <= 'Z' {
			ct += 'a' - 'A'
		}
		if cs == '\\' {
			cs = '/'
		}
		if ct == '\\' {
			ct = '/'
		}
		if cs != ct {
			return false
		}
	}
	return i >= len(s) || s[i] == '/' || s[i] == '\\'
}

func linkgetline(ctxt *Link, line int32, f **LSym, l *int32) {
	var a [HISTSZ]struct {
		incl *Hist
		idel int32
		line *Hist
		ldel int32
	}
	var lno int32
	var d int32
	var dlno int32
	var n int
	var h *Hist
	var buf string
	var buf1 string
	var file string
	lno = int32(line)
	n = 0
	for h = ctxt.Hist; h != nil; h = h.Link {
		if h.Offset < 0 {
			continue
		}
		if lno < h.Line {
			break
		}
		if h.Name != "<pop>" {
			if h.Offset > 0 {
				// #line directive
				if n > 0 && n < HISTSZ {
					a[n-1].line = h
					a[n-1].ldel = h.Line - h.Offset + 1
				}
			} else {
				// beginning of file
				if n < HISTSZ {
					a[n].incl = h
					a[n].idel = h.Line
					a[n].line = nil
				}
				n++
			}
			continue
		}
		n--
		if n > 0 && n < HISTSZ {
			d = h.Line - a[n].incl.Line
			a[n-1].ldel += d
			a[n-1].idel += d
		}
	}
	if n > HISTSZ {
		n = HISTSZ
	}
	if n <= 0 {
		*f = Linklookup(ctxt, "??", HistVersion)
		*l = 0
		return
	}
	n--
	if a[n].line != nil {
		file = a[n].line.Name
		dlno = a[n].ldel - 1
	} else {
		file = a[n].incl.Name
		dlno = a[n].idel - 1
	}
	if (ctxt.Windows == 0 && file[0] == '/') || (ctxt.Windows != 0 && file[1] == ':') || file[0] == '<' {
		buf = fmt.Sprintf("%s", file)
	} else {
		buf = fmt.Sprintf("%s/%s", ctxt.Pathname, file)
	}
	// Remove leading ctxt->trimpath, or else rewrite $GOROOT to $GOROOT_FINAL.
	if ctxt.Trimpath != "" && haspathprefix(buf, ctxt.Trimpath) {
		if len(buf) == len(ctxt.Trimpath) {
			buf = "??"
		} else {
			buf1 = fmt.Sprintf("%s", buf[len(ctxt.Trimpath)+1:])
			if buf1[0] == '\x00' {
				buf1 = "??"
			}
			buf = buf1
		}
	} else if ctxt.Goroot_final != "" && haspathprefix(buf, ctxt.Goroot) {
		buf1 = fmt.Sprintf("%s%s", ctxt.Goroot_final, buf[len(ctxt.Goroot):])
		buf = buf1
	}
	lno -= dlno
	*f = Linklookup(ctxt, buf, HistVersion)
	*l = lno
}

func linkprfile(ctxt *Link, line int) {
	l := int32(line)
	var i int
	var n int
	var a [HISTSZ]Hist
	var h *Hist
	var d int32
	n = 0
	for h = ctxt.Hist; h != nil; h = h.Link {
		if l < h.Line {
			break
		}
		if h.Name != "<pop>" {
			if h.Offset == 0 {
				if n >= 0 && n < HISTSZ {
					a[n] = *h
				}
				n++
				continue
			}
			if n > 0 && n < HISTSZ {
				if a[n-1].Offset == 0 {
					a[n] = *h
					n++
				} else {
					a[n-1] = *h
				}
			}
			continue
		}
		n--
		if n >= 0 && n < HISTSZ {
			d = h.Line - a[n].Line
			for i = 0; i < n; i++ {
				a[i].Line += d
			}
		}
	}
	if n > HISTSZ {
		n = HISTSZ
	}
	for i = 0; i < n; i++ {
		fmt.Printf("%s:%d ", a[i].Name, int(l-a[i].Line+a[i].Offset+1))
	}
}

func wrdata(b *Biobuf, v []byte) {
	wrint(b, int64(len(v)))
	Bwrite(b, v)
}

func wrstring(b *Biobuf, s string) {
	wrint(b, int64(len(s)))
	b.w.WriteString(s)
}

func wrpath(ctxt *Link, b *Biobuf, p string) {
	wrstring(b, filepath.ToSlash(p))
}

func wrint(b *Biobuf, sval int64) {
	var uv uint64
	var v uint64
	var buf [10]uint8
	var p []uint8
	uv = (uint64(sval) << 1) ^ uint64(int64(sval>>63))
	p = buf[:]
	for v = uv; v >= 0x80; v >>= 7 {
		p[0] = uint8(v | 0x80)
		p = p[1:]
	}
	p[0] = uint8(v)
	p = p[1:]
	Bwrite(b, buf[:len(buf)-len(p)])
}

slice Pcln.funcdata Pcln.nfuncdata Pcln.mfuncdata
slice Pcln.pcdata Pcln.npcdata Pcln.mpcdata
slice Pcln.file Pcln.nfile Pcln.mfile
slice Pcln.funcdataoff Pcln.nfuncdata

func addvarint(ctxt *Link, d *Pcdata, val uint32) {
	var v uint32
	for v = val; v >= 0x80; v >>= 7 {
		d.P = append(d.P, uint8(v|0x80))
	}
	d.P = append(d.P, uint8(v))
}

diff {
-	for i = 0; i < int32(len(pcln.File)); i++ {
-		if pcln.File[i] == f {
-			pcln.Lastfile = f
-			pcln.Lastindex = int(i)
-			return i
-		}
-	}
-
-	if len(pcln.File) >= cap(pcln.File) {
-		cap(pcln.File) = (len(pcln.File) + 1) * 2
-		pcln.File = erealloc(pcln.File, cap(pcln.File)*sizeof(pcln.File[0])).([]*LSym)
-	}
-
-	pcln.File[len(pcln.File)] = f
-	len(pcln.File)++
+	for i = 0; i < int32(len(pcln.File)); i++ {
+		file := pcln.File[i]
+		if file == f {
+			pcln.Lastfile = f
+			pcln.Lastindex = int(i)
+			return int32(i)
+		}
+	}
+	pcln.File = append(pcln.File, f)
}
diff {
-	var n int
-	var havepc *uint32
-	var havefunc *uint32
}
diff {
-	n = ((npcdata+31)/32 + (nfuncdata+31)/32) * 4
-
-	havepc = (*uint32)(make([]byte, n))
-	havefunc = havepc + (npcdata+31)/32
+	havepc := make([]uint32, (npcdata+31)/32)
+	havefunc := make([]uint32, (nfuncdata+31)/32)
}

func yy_isalpha(c int) bool {
	return 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'
}
diff {
-	nuxiinit(arch)
}
diff {
-	ctxt.Goroot_final = Getenv("GOROOT_FINAL")
-	if ctxt.Goroot_final != "" && ctxt.Goroot_final[0] == '\x00' {
-		ctxt.Goroot_final = ""
-	}
+	ctxt.Goroot_final = os.Getenv("GOROOT_FINAL")
}
diff {
-	p = obj.Getgoarch()
+	p = Getgoarch()
}
diff {
-	if getwd(buf, sizeof(buf)) == 0 {
-		buf = "/???"
-	}
-	if yy_isalpha(int(buf[0])) && buf[1] == ':' {
-		// On Windows.
-		ctxt.Windows = 1
-
-		// Canonicalize path by converting \ to / (Windows accepts both).
-		for p = buf; p[0] != 0; p = p[1:] {
-			if p[0] == '\\' {
-				p[0] = '/'
-			}
-		}
-	}
+	buf, _ = os.Getwd()
+	if buf == "" {
+		buf = "/???"
+	}
+	buf = filepath.ToSlash(buf)
}

export linksymfmt
func Linksymfmt(s *LSym) string {
	if s == nil {
		return "<nil>"
	}
	return s.Name
}

slice asmoutnacl.out
slice asmout.out

bool immfloat.return
bool immhalf.return
bool cmp.return
bool isdata.return
bool iscall.return
bool LinkArch.iscall.return
bool LinkArch.isdata.return

diff {
-			xcmp[i][n] = uint8(bool2int(cmp(n, i)))
+			if cmp(n, i) {
+				xcmp[i][n] = 1
+			}
}

diff {
-			fmt.Fprintf(ctxt.Bso, "%5.2f span1\n", obj.Cputime())
+			fmt.Fprintf(ctxt.Bso, "%5.2f span1\n", obj.Cputime())
}

slice oplook.o
slice oplook.e
slice Oprang.start
slice Oprang.stop

delete listinit5 listinit6 listinit8 listinit9

diff {
-		op = string(&"<<>>->@>"[((v>>5)&3)<<1])
+		op = string("<<>>->@>"[((v>>5)&3)<<1:])
}

delete DSconv

diff {
type Prog struct {
+	Ctxt *Link
}

diff {
type LinkArch struct {
+	Pconv func(*Prog) string
}

diff {
= obj.LinkArch{
+	Pconv: Pconv,
}

diff {
amd64 = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
amd64p32 = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
arm = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
386 = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
ppc64 = obj.LinkArch{
+	ByteOrder: binary.BigEndian,
}
diff {
ppc64le = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
= obj.LinkArch{
+	Rconv: Rconv,
}
diff {
= obj.LinkArch{
+	Dconv: Dconv,
}

diff {
-		obj.Memmove(p, nop[m-1], m)
+		copy(p[:m], nop[m-1][:m])
}
diff {
-			obj.Memmove(s.P[p.Pc:], ctxt.And, m)
+			copy(s.P[p.Pc:][:m], ctxt.And[:m])
}

# TODO(rsc): Why does len rewrite not catch this?
diff {
-	wrdata(b, s.P, len(s.P))
+	wrdata(b, s.P)
}

diff {
-		obj.Memmove(and0[np+1:], and0[np:], n-np)
+		copy(and0[np+1:], and0[np:n])
}

diff {
-		fmt.Fprintf(ctxt.Bso, "%5.2f noops\n", obj.Cputime())
+		fmt.Fprintf(ctxt.Bso, "%5.2f noops\n", obj.Cputime())
}
diff {
-			cast = []byte(&out[i])
-			for j = 0; j < 4; j++ {
-				bp[0] = cast[obj.Inuxi4[j]]
-				bp = bp[1:]
-			}
+			ctxt.Arch.ByteOrder.PutUint32(bp, out[i])
+			bp = bp[4:]
}
diff {
	var i int32
-	var j int32
	var bp []byte
-	var cast []byte
}

diff {
-	var p string
	var h uint32
-	var c int

	h = uint32(v)
-	for p = symb; ; p = p[1:] {
-		c = int(p[0])
-		if !(c != 0) {
-			break
-		}
+	for i := 0; i < len(symb); i++ {
+		c := int(symb[i])
}
diff {
-	StackPreempt = 1
+	StackPreempt = -1314 // 0xfff...fade
}
diff {
-		p.From.Offset = int64(uint32(obj.StackPreempt))
+		p.From.Offset = int64(uint32(obj.StackPreempt & (1<<32-1)))
}
diff {
-		p.To.Offset = int64(uint32(obj.StackPreempt))
+		p.To.Offset = int64(uint32(obj.StackPreempt & (1<<32-1)))
}
diff {
-	if (ctxt.Windows == 0 && file[0] == '/') || (ctxt.Windows != 0 && file[1] == ':') || file[0] == '<' {
+	if filepath.IsAbs(file) || strings.HasPrefix(file, "<") {
}
diff {
-	p = Getgoarch()
-	if p != arch.Name {
-		log.Fatalf("invalid goarch %s (want %s)", p, arch.Name)
-	}
-
}

# export linkprfile via diff, because it was supplied as a func above.
# the matching for the func doesn't work right if you say func Linkprfile,
# but the func overrides any 'export linkprfile'.
diff {
-func linkprfile(ctxt *Link, line int) {
+func Linkprfile(ctxt *Link, line int) {
}

func prg() *obj.Prog {
	p := zprg
	return &p
}

diff {
-	Exits("unknown experiment")
+	os.Exit(2)
}

func linksetexp() {
	for _, f := range strings.Split(goexperiment, ",") {
		if f != "" {
			addexp(f)
		}
	}
}

export expstring
func Expstring() string {
	buf := "X"
	for i := range exper {
		if *exper[i].val != 0 {
			buf += "," + exper[i].name
		}
	}
	if buf == "X" {
		buf += ",none"
	}
	return "X:" + buf[2:]
}

diff {
-			ctxt.Diag("argument %v is TYPE_CONST, should be TYPE_ADDR, in %v", Dconv(p, 0, a), p)
+			ctxt.Diag("argument is TYPE_CONST, should be TYPE_ADDR, in %v", p)
}

diff {
-			ctxt.Diag("argument %v is TYPE_ADDR, should be TYPE_CONST, in %v", Dconv(p, 0, a), p)
+			ctxt.Diag("argument is TYPE_ADDR, should be TYPE_CONST, in %v", p)
}

diff {
-	ctxt.Diag("invalid encoding for argument %v in %v", Dconv(p, 0, a), p)
+	ctxt.Diag("invalid encoding for argument %v", p)
}

diff {
-	ArgsSizeUnknown            = 0x80000000
+	ArgsSizeUnknown            = -0x80000000
}

diff {
-new(Prog)
+ctxt.NewProg()
}
diff {
-				if str[0] == 0 {
+				if str == "" {
					str += "[R"
}

# compiler starts roughly here

diff {
-	b [XXX]uint32
+	b []uint32
}

func bvalloc(n int32) *Bvec {
	return &Bvec{n, make([]uint32, bvsize(uint32(n))/4)}
}

diff {
-	return obj.Memcmp(bv1.b, bv2.b, int(nbytes))
+	for i, x := range bv1.b {
+		if x != bv2.b[i] {
+			return 1
+		}
+	}
+	return 0
}

diff {
-	obj.Memmove(dst.b, src.b, bvsize(uint32(dst.n)))
+	for i, x := range src.b {
+		dst.b[i] = x
+	}
}

diff {
-	obj.Memset(bv.b, 0x00, bvsize(bv.n))
+	for i := range bv.b {
+		bv.b[i] = 0
+	}
}

diff {
- indent((*obj.Fmt)(fp))
+ fp = indent(fp)
}

func indent(s string) string {
	return s + "\n" + strings.Repeat(".   ", dumpdepth)
}

slice dotoffset.oary

delete DEFAULTCAPACITY arraynew arrayfree arraylength arrayget arrayset ensurecapacity arrayadd arraysort

slice Liveness.uevar
slice Liveness.varkill
slice Liveness.livein
slice Liveness.liveout
slice Liveness.avarinit
slice Liveness.avarinitany
slice Liveness.avarinitall
slice inithash.autohash inithash.nautohash
slice indexdup.hash indexdup.nhash
slice keydup.hash keydup.nhash
slice fielddup.hash fielddup.nhash
slice typecheckcomplit.hash typecheckcomplit.nhash

diff {
-func vmkcall(fn *Node, t *Type, init **NodeList, va []interface{}) *Node {
+func vmkcall(fn *Node, t *Type, init **NodeList, va []*Node) *Node {
}

diff {
	for i = 0; i < n; i++ {
-		args = list(args, va_arg(va, *Node))
+		args = list(args, va[i])
}

func mkcall(name string, t *Type, init **NodeList, args ...*Node) *Node {
	return vmkcall(syslook(name, 0), t, init, args)
}

func mkcall1(fn *Node, t *Type, init **NodeList, args ...*Node) *Node {
	return vmkcall(fn, t, init, args)
}

diff {
- hash = hash[:inithash(n, (***Node)(&hash), autohash[:])]
+ hash = inithash(n, autohash[:])
}

diff {
- func inithash(n *Node, hash ***Node, autohash []*Node) uint32 {
+ func inithash(n *Node, autohash []*Node) []*Node {
}
diff {
-		*hash = &autohash[0]
-		for i = 0; i < len(autohash); i++ {
-			(*hash)[i] = nil
-		}
-		return uint32(len(autohash))
+		for i := range autohash {
+			autohash[i] = nil
+		}
+		return autohash
}
diff {
	// build and return a throw-away hash table
-	*hash = make([]*Node, h)
-
-	for i = 0; i < h; i++ {
-		(*hash)[i] = nil
-	}
-	return h
+	return make([]*Node, h)
}
diff {
-		s = string(&d)
-		b = 0
-		for i = sizeof(d); i > 0; i-- {
-			b = b*PRIME1 + uint32(s[0])
-			s = s[1:]
-		}
+		x := math.Float64bits(d)
+		for i := 0; i < 8; i++ {
+			b = b*PRIME1 + uint32(x&0xFF)
+			x >>= 8
+		}
}

diff {
func onearg(n *Node, f string, args ...interface{}) int {
-	var arg []interface{}
}
diff {
-		obj.Va_start(arg, f)
-		p = obj.Vsmprint(f, arg)
-		obj.Va_end(arg)
+		p = fmt.Sprintf(f, args...)
}

diff {
-		if descbuf < sizeof(descbuf) {
			desc = descbuf
-		} else {
-			desc = "function argument"
-		}
}

slice postorder.rpo2r
slice flowrpo.rpo2r
slice rpolca.idom
slice loophead.idom
slice flowrpo.idom
slice doms.idom
slice Graph.rpo
slice InitPlan.e
slice err nerr merr
rename err errors
slice ispkgin.pkgs ispkgin.n
slice mergetemp.var mergetemp.nvar
rename append walkappend

func stringtoarraylit(np **Node) {
	n := *np
	if n.Left.Op != OLITERAL || n.Left.Val.Ctype != CTSTR {
		Fatal("stringtoarraylit %N", n)
	}

	s := n.Left.Val.U.Sval.S
	var l *NodeList
	if n.Type.Type.Etype == TUINT8 {
		// []byte
		for i := 0; i < len(s); i++ {
			l = list(l, Nod(OKEY, Nodintconst(int64(i)), Nodintconst(int64(s[0]))))
		}
	} else {
		// []rune
		i := 0
		for _, r := range s {
			l = list(l, Nod(OKEY, Nodintconst(int64(i)), Nodintconst(int64(r))))
			i++
		}
	}

	nn := Nod(OCOMPLIT, nil, typenod(n.Type))
	nn.List = l
	typecheck(&nn, Erv)
	*np = nn
}
diff {
-func sprint_depchain(fmt_ *obj.Fmt, stack *NodeList, cur *Node, first *Node) {
+func sprint_depchain(fmt_ *string, stack *NodeList, cur *Node, first *Node) {
}
diff {
-			fmt_ += fmt.Sprintf("\n\t%v: %v uses %v", l.N.Line(), Nconv(l.N, 0), Nconv(cur, 0))
+			*fmt_ += fmt.Sprintf("\n\t%v: %v uses %v", l.N.Line(), Nconv(l.N, 0), Nconv(cur, 0))
}
diff {
-			sprint_depchain((*obj.Fmt)(&fmt_), typecheck_tcstack, n, n)
+			sprint_depchain(&fmt_, typecheck_tcstack, n, n)
}

func newstrlit(s string) *Strlit {
	return &Strlit{
		S: s,
	}
}

func pathtoprefix(s string) string {
	slash := strings.LastIndex(s, "/")
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c <= ' ' || i >= slash && c == '.' || c == '%' || c == '"' || c >= 0x7F {
			goto escape
		}
	}
	return s

escape:
	var buf bytes.Buffer
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c <= ' ' || i >= slash && c == '.' || c == '%' || c == '"' || c >= 0x7F {
			fmt.Fprintf(&buf, "%%%02x", c)
			continue
		}
		buf.WriteByte(c)
	}
	return buf.String()
}

diff {
-		n.List = (*NodeList)(1)
+		n.List = nil
}

bool eqnote.return

func eqnote(a, b *Strlit) bool {
	return a == b || a != nil && b != nil && a.S == b.S
}

delete remal mal

diff {
-	s.Name = string(make([]byte, obj.Strlen(name)+1))
}

func entry(p *InitPlan) *InitEntry {
	p.E = append(p.E, InitEntry{})
	return &p.E[len(p.E)-1]
}

diff {
-	obj.Va_start(arg, fmt_)
-	obj.Vfprint(1, fmt_, arg)
-	obj.Va_end(arg)
+	fmt.Printf(fmt_, args...)
}
diff {
func Fatal(fmt_ string, args ...interface{}) {
-	var arg []interface{}
}

diff {
-	var arg []interface{}
-
-	obj.Va_start(arg, fmt_)
-	adderr(line, fmt_, arg)
-	obj.Va_end(arg)
+	adderr(line, fmt_, args)
}

diff {
-	obj.Va_start(arg, fmt_)
-	adderr(parserline(), fmt_, arg)
-	obj.Va_end(arg)
+	adderr(parserline(), fmt_, args)
}

diff {
func Yyerror(fmt_ string, args ...interface{}) {
	var i int
-	var arg []interface{}
}

func adderr(line int, format string, args []interface{}) {
	errors = append(errors, Error{
		seq: len(errors),
		lineno: line,
		msg: fmt.Sprintf("%v: %s\n", Ctxt.Line(line), fmt.Sprintf(format, args...)),
	})
}

delete ucistrcmp

diff {
-	if strings.HasPrefix(obj.Getgoversion(), "release") {
+	if strings.HasPrefix(obj.Getgoversion(), "release") {
}

diff {
-			obj.Strecpy(buf, buf[sizeof(buf):], fmt_)
-
-			p = obj.Strstr(buf, "{ or {")
-			if p != "" {
-				obj.Memmove(p[1:], p[6:], len(p+6)+1)
-			}
-
-			// The grammar has ? and @ but only for reading imports.
-			// Silence them in ordinary errors.
-			p = obj.Strstr(buf, " or ?")
-
-			if p != "" {
-				obj.Memmove(p, p[5:], len(p+5)+1)
-			}
-			p = obj.Strstr(buf, " or @")
-			if p != "" {
-				obj.Memmove(p, p[5:], len(p+5)+1)
-			}
-			fmt_ = buf
+			// The grammar has ? and @ but only for reading imports.
+			// Silence them in ordinary errors.
+			fmt_ = strings.Replace(fmt_, "{ or {", "{", -1)
+			fmt_ = strings.Replace(fmt_, " or ?", "", -1)
+			fmt_ = strings.Replace(fmt_, " or @", "", -1)
}

diff {
-		*(*int)(0) = 0
+		var x *int
+		*x = 0
}
diff {
-obj.Remove(outfile)
+os.Remove(outfile)
}
diff {
-obj.Exits("error")
+os.Exit(2)
}

diff {
- obj.Atoi(note.S[4:])
+ atoi(note.S[4:])
}

diff {
- uint32(^0)
+ ^uint32(0)
}
diff {
-	obj.Snprint(namebuf, sizeof(namebuf), namefmt, makefuncdatasym_nsym)
+	namebuf = fmt.Sprintf(namefmt, makefuncdatasym_nsym)
}
diff {
-	b = obj.Bopen(asmhdr, obj.OWRITE)
-	if b == nil {
-		Fatal("open %s: %v", asmhdr, err)
-	}
+	b, err := obj.Bopenw(asmhdr)
+	if err != nil {
+		Fatal("%v", err)
+	}
}

bool exportname.return
func exportname(s string) bool {
	if s[0] < utf8.RuneSelf {
		return 'A' <= s[0] && s[0] <= 'Z'
	}
	r, _ := utf8.DecodeRuneInString(s)
	return unicode.IsUpper(r)
}

diff {
-	if strings.ContainsRune(s.Name, CenterDot) {
-		name = s.Name
-		main.Utfrune(name, CenterDot) = ""
-	}
+	if i := strings.Index(s.Name, string(CenterDot)); i >= 0 {
+		name = s.Name[:i]
+	}
}
diff {
-					obj.Memmove(str.S[len:], nr.Val.U.Sval.S, len(nr.Val.U.Sval.S))
+					str.S += nr.Val.U.Sval.S
}
func cmpslit(l, r *Node) int {
	return strings.Compare(l.Val.U.Sval.S, r.Val.U.Sval.S)
}

func islocalname(name *Strlit) bool {
	return strings.HasPrefix(name.S, "/") ||
		Ctxt.Windows != 0 && len(name.S) >= 3 && yy_isalpha(int(name.S[0])) && name.S[1] == ':' && name.S[2] == '/' ||
		strings.HasPrefix(name.S, "./") || name.S == "." ||
		strings.HasPrefix(name.S, "../") || name.S == ".."
}

bool islocalname.return

diff {
-		l = main.Runelen(rune_)
-		s = (*Strlit)(make([]byte, sizeof(*s)+l))
-		s.S = s.S[:l]
-		main.Runetochar(string(s.S), &rune_)
+		s = &Strlit{S: string(rune_)}
}

diff {
-func getvariables(fn *Node) *Array {
-	var result *Array
+func getvariables(fn *Node) []*Node {
+	var result []*Node
}
diff {
-func newcfg(firstp *obj.Prog) *Array {
+func newcfg(firstp *obj.Prog) []*BasicBlock {
}
diff {
-var selectgo *Array
+var selectgo []*BasicBlock
}
diff {
-	return (*Array)(cfg)
+	return cfg
}
diff {
-func newliveness(fn *Node, ptxt *obj.Prog, cfg *Array, vars *Array) *Liveness {
+func newliveness(fn *Node, ptxt *obj.Prog, cfg []*BasicBlock, vars []*Node) *Liveness {
}
diff {
-	var cfg *Array
+	var cfg []*BasicBlock
}
diff {
-	var vars *Array
+	var vars []*Node
}
diff {
-	arraysort((*Array)(cfg), blockrpocmp)
+	sort.Sort(blockrpocmp(cfg))
}
diff {
-func blockrpocmp(p1 interface{}, p2 interface{}) int {
-	var bb1 *BasicBlock
-	var bb2 *BasicBlock
-
-	bb1 = *p1.(**BasicBlock)
-	bb2 = *p2.(**BasicBlock)
-	if bb1.rpo < bb2.rpo {
-		return -1
-	}
-	if bb1.rpo > bb2.rpo {
-		return 1
-	}
-	return 0
-}
+type blockrpocmp []*BasicBlock
+func (x blockrpocmp) Len() int { return len(x) }
+func (x blockrpocmp) Swap(i, j int) { x[i], x[j] = x[j], x[i]}
+func (x blockrpocmp) Less(i, j int) bool { return x[i].rpo < x[j].rpo }
}

rename twobitwritesymbol.len n

diff {
-	obj.Memset(remap, 0xff, n*sizeof(remap[0]))
+	for i := range remap {
+		remap[i] = -1
+	}
}

diff {
-	obj.Memset(table, 0xff, tablesize*sizeof(table[0]))
+	for i := range table {
+		table[i] = -1
+	}
}

bool isfunny.return
func isfunny(n *Node) bool {
	return n.Sym != nil && (n.Sym.Name == ".fp" || n.Sym.Name == ".args")
}

rename freecfg.len n

diff {
- cfg = append(cfg, p.Link.Opt)
+ cfg = append(cfg, p.Link.Opt.(*BasicBlock))
}
diff {
- cfg = append(cfg, p.To.U.Branch.Opt)
+ cfg = append(cfg, p.To.U.Branch.Opt.(*BasicBlock))
}
diff {
- Fatal("bad bookkeeping in liveness %v %d", Nconv(to.Node, 0), pos)
+ Fatal("bad bookkeeping in liveness %v %d", Nconv(to.Node.(*Node), 0), pos)
}
diff {
- Fatal("bad bookkeeping in liveness %v %d", Nconv(from.Node, 0), pos)
+ Fatal("bad bookkeeping in liveness %v %d", Nconv(from.Node.(*Node), 0), pos)
}

diff {
-		mphextofix(&a.Val, start, -cap(s)+cap(start))
+		mphextofix(&a.Val, start)
}

diff {
-	mphextofix(a, s0, -cap(s)+cap(s0))
+	mphextofix(a, s0)
}

diff {
-func mphextofix(a *Mpint, s string, n int) {
+func mphextofix(a *Mpint, s string) {
}
diff {
-	for s[0] == '0' {
+	for s != "" && s[0] == '0' {
		s = s[1:]
-		n--
}
diff {
-	if 4*n > Mpscale*Mpprec {
+	if 4*len(s) > Mpscale*Mpprec {
}
diff {
-	end = n - 1
+	end = len(s) - 1
	for hexdigitp = end; hexdigitp >= 0; hexdigitp-- {
}

diff {
-			if dp-ex >= 1<<(8*sizeof(dp)-3) || int(int16(4*(dp-ex))) != 4*(dp-ex) {
+			if dp-ex >= 1<<(32-3) || int(int16(4*(dp-ex))) != 4*(dp-ex) {
}
diff {
func Bconv(xval *Mpint, flag int) string {
-	var buf string
+	var buf [500]byte
}
diff {
-	p = sizeof(buf)
-	p--
-	buf[p] = 0
+	p = len(buf)
}
diff {
-	fp += &buf[p]
+	fp += string(buf[p:])
}
diff {
-		d *= obj.Pow(10, dexp-float64(exp))
+		d *= math.Pow(10, dexp-float64(exp))
}
diff {
-	f = obj.Ldexp(f, e)
+	f = math.Ldexp(f, e)
}
diff {
-	f = obj.Frexp(c, &i)
+	f, i = math.Frexp(c)
}
diff {
-		l = int(obj.Floor(f))
+		l = int(math.Floor(f))
}

export ctxt
delete Lconv

diff {
-		if 0 <= x && x <= main.Runemax {
+		if 0 <= x && x <= utf8.MaxRune {
}
diff {
-		case main.Runeerror:
+		case utf8.RuneError:
}
diff {
func Zconv(sp *Strlit, flag int) string {
-	var r uint
}
diff {
-	s = sp.S
-	se = s[len(sp.S):]
-
	// NOTE: Keep in sync with ../ld/go.c:/^Zconv.
-	for s < se {
-		n = main.Chartorune(&r, s)
-		s = s[n:]
+	s = sp.S
+	for i := 0; i < len(s); i += n {
+		var r rune
+		r, n = utf8.DecodeRuneInString(s[i:])
}
diff {
-				fp += fmt.Sprintf("\\x%02x", uint8(*(s - 1)))
+				fp += fmt.Sprintf("\\x%02x", s[i])
}
diff {
-			obj.Fmtrune((*obj.Fmt)(fp), '\\')
-			obj.Fmtrune((*obj.Fmt)(fp), int(r))
+			fp += `\` + string(r)
}
diff {
-			obj.Fmtrune((*obj.Fmt)(fp), int(r))
+			fp += string(r)
}
diff {
-func symfmt(s *Sym) string {
+func symfmt(s *Sym, flag int) string {
}
diff {
-func typefmt(t *Type) string {
+func typefmt(t *Type, flag int) string {
}
diff {
-	r = int(symfmt((*Sym)(fp), s))
+	_ = r
+	str := symfmt(s, flag)
	flag = sf
	fmtmode = sm
-	return string(r)
+	return str
}
diff {
-	r = int(typefmt((*Type)(fp), t))
+	_ = r
+	str := typefmt(t, flag)

	if fmtmode == FTypeId && (sf&obj.FmtUnsigned != 0) {
		fmtpkgpfx--
	}

	flag = sf
	fmtmode = sm
	t.Trecur--
-	return string(r)
+	return str
}
diff {
-	r = -1
+	_ = r
+	var str string
	switch fmtmode {
	case FErr,
		FExp:
-		r = int(nodefmt((*Node)(fp), n))
+		str = nodefmt(n, flag)

	case FDbg:
		dumpdepth++
-		r = int(nodedump((*Node)(fp), n))
+		str = nodedump(n, flag)
		dumpdepth--

	default:
		Fatal("unhandled %N mode")
	}

	flag = sf
	fmtmode = sm
-	return string(r)
+	return str
}
diff {
-	r = 0
+	_ = r
	sep = "; "
}
diff {
	for ; l != nil; l = l.Next {
		fp += fmt.Sprintf("%v", Nconv(l.N, 0))
-		r += 0
		if l.Next != nil {
			fp += sep
-			r += 0
		}
	}

	flag = sf
	fmtmode = sm
-	return string(r)
+	return fp
}
diff {
		// skip leading "type." in method name
-		p = main.Utfrrune(s.Name, '.')
-
-		if p != "" {
-			p = p[1:]
-		} else {
-			p = s.Name
-		}
+		p = s.Name
+		if i := strings.LastIndex(s.Name, "."); i >= 0 {
+			p = s.Name[i+1:]
+		}
}
diff {
-func nodefmt(n *Node) string {
+func nodefmt(n *Node, flag int) string {
}
diff {
-		return stmtfmt((*Node)(f), n)
+		return stmtfmt(n)
}
diff {
-func nodedump(n *Node) string {
+func nodedump(n *Node, flag int) string {
}
diff {
-		return obj.Linksymfmt((*obj.LSym)(fp))
+		panic("linksymfmt")
}
diff {
-	var sf uint32
+	var sf int
}
diff {
-func setfmode(flags *uint32) int {
+func setfmode(flags *int) int {
}
diff {
-var fmtmode int
+var fmtmode int = FErr
}
delete fmtinstallgo
rename arch Thearch
diff {
-		md5write(d, tmp[:], 56-len%64)
+		md5write(d, tmp[:], int(56-len%64))
}
diff {
-		md5write(d, tmp[:], 64+56-len%64)
+		md5write(d, tmp[:], int(64+56-len%64))
}
diff {
func dumpobj() {
	var externs *NodeList
	var tmp *NodeList
-	var arhdr string
+	var arhdr [ArhdrSize]byte
}
diff {
-obj.Memset(arhdr, 0, sizeof(arhdr))
+arhdr = [ArhdrSize]byte{}
}
diff {
-obj.Memset(arhdr, 0, ArhdrSize)
+arhdr = [ArhdrSize]byte{}
}
diff {
-		formathdr(arhdr, "__.PKGDEF", size)
+		formathdr(arhdr[:], "__.PKGDEF", size)
}
diff {
-obj.Bwrite(bout, arhdr, ArhdrSize)
+obj.Bwrite(bout, arhdr[:])
}
diff {
-obj.Bwrite(bout, arhdr, sizeof(arhdr))
+obj.Bwrite(bout, arhdr[:])
}
diff {
-		formathdr(arhdr, namebuf, size)
+		formathdr(arhdr[:], namebuf, size)
}
func formathdr(arhdr []byte, name string, size int64) {
	copy(arhdr[:], fmt.Sprintf("%-16s%-12d%-6d%-6d%-8o%-10d`\n", name, 0, 0, 0, 0644, size))
}
diff {
-	obj.Memmove(p.To.U.Sval, t, n)
+	p.To.U.Sval = t
}
diff {
-	lit = (*Strlit)(make([]byte, sizeof(*lit)+n))
+	lit = new(Strlit)
}
diff {
-
-		obj.Memmove(tmp.lit.S, s, len)
-		tmp.lit.S[len] = '\x00'
+		tmp.lit.S = s
}
func Bputname(b *obj.Biobuf, s *obj.LSym) {
	obj.Bwritestring(b, s.Name)
	obj.Bputc(b, 0)
}
diff {
-var pragcgobuf obj.Fmt
+var pragcgobuf string
}
diff {
-	if pragcgobuf.To > pragcgobuf.Start {
+	if pragcgobuf != "" {
}
diff {
-fmt.Fprintf(bout, "go object %s %s %s %s\n", obj.Getgoos(), obj.Getgoarch(), obj.Getgoversion(), obj.Expstring())
+fmt.Fprintf(bout, "go object %s %s %s %s\n", obj.Getgoos(), obj.Getgoarch(), obj.Getgoversion(), obj.Expstring())
}
diff {
-	bout = obj.Bopen(outfile, obj.OWRITE)
-	if bout == nil {
+	var err error
+	bout, err = obj.Bopenw(outfile)
+	if err != nil {
}
diff {
-obj.Bwrite(bout, "!<arch>\n", 8)
+obj.Bwritestring(bout, "!<arch>\n")
}
diff {
-	obj.Writeobj(Ctxt, bout)
+	obj.Writeobjdirect(Ctxt, bout)
}

export nod
bool yy_isdigit.return
bool yy_isspace.return
bool yy_isalpha.return
bool yy_isalnum.return
bool nacl
bool isfrog.return
bool more.return

diff {
- obj.Isalnum(c) != 0
+ isalnum(c)
}
diff {
- obj.Isdigit(c) != 0
+ isdigit(c)
}
diff {
-obj.Exits("usage")
+os.Exit(2)
}
diff {
-func Gcmain(argc int, argv [XXX]string) int {
+func Main() {
}
diff {
-	for i = 0; i < main.BITS; i++ {
+	for i = 0; i < BITS; i++ {
}
diff {
-	obj.Signal(obj.SIGBUS, fault)
}
diff {
-	obj.Signal(obj.SIGSEGV, fault)
}
diff {
-	obj.Notify(catcher)
}
diff {
-	// Tell the FPU to handle all exceptions.
-	obj.Setfcr(obj.FPPDBL | obj.FPRNR)
}
diff {
-	p = Getgoarch()
+	p = obj.Getgoarch()
}
diff {
-	obj.Binit(&bstdout, 1, obj.OWRITE)
+	bstdout = *obj.Binitw(os.Stdout)
}
diff {
-	goroot = obj.Getgoroot()
-	goos = obj.Getgoos()
+	goroot = obj.Getgoroot()
+	goos = obj.Getgoos()
}
diff {
-	pragcgobuf = ""
}
diff {
-	obj.Quotefmtinstall()
}

export getgoarm
diff {
-	obj.Flagparse(&argc, (**string)(&argv), usage)
+	obj.Flagparse(usage)
}
diff {
-		var f [100]string
-		var i int
		var j int
-		var nf int
-
-		nf = obj.Getfields(debugstr, (*string)(f), 1, int(","))
+		f := strings.Split(debugstr, ",")
-		for i = 0; i < nf; i++ {
+		for i := range f {
+			if f[i] == "" {
+				continue
+			}
}
diff {
-	fmtinstallgo()
}
diff {
-	for i = 0; i < argc; i++ {
-		infile = argv[i]
+	for _, infile = range flag.Args() {
}
diff {
-		curio.bin = obj.Bopen(infile, obj.OREAD)
-		if curio.bin == nil {
+		var err error
+		curio.bin, err = obj.Bopenr(infile)
+		if err != nil {
}
diff {
-	obj.Exits("")
-	return 0
}
delete catcher
diff {
-if argc < 1 {
+if flag.NArg() < 1 {
}
diff {
-	obj.Exits("")
+	os.Exit(0)
}
diff {
-	obj.Cleanname(q)
+	q = path.Clean(q)
}
diff {
-	obj.Cleanname(cleanbuf)
+	cleanbuf = path.Clean(cleanbuf)
}

func arsize(b *obj.Biobuf, name string) int {
	var buf [ArhdrSize]byte
	if _, err := io.ReadFull(b, buf[:]); err != nil {
		return -1
	}
	aname := strings.Trim(string(buf[0:16]), " ")
	if !strings.HasPrefix(aname, name) {
		return -1
	}
	asize := strings.Trim(string(buf[48:58]), " ")
	i, _ := strconv.Atoi(asize)
	return i
}
diff {
-	p = obj.Brdline(b, '\n').(string)
+	p = obj.Brdline(b, '\n')
}
diff {
-	if obj.Memcmp(p, "!<arch>\n", 8) != 0 {
+	if p != "!<arch>\n" {
}
diff {
-		cleanbuf = string(make([]byte, obj.Strlen(prefix)+obj.Strlen(path_.S)+2))
}
diff {
-	q = string(make([]byte, len(name.S)+1))
-
-	obj.Memmove(q, name.S, len(name.S))
-	q[len(name.S)] = '\x00'
-	q = path.Clean(q)
-	if len(q) != len(name.S) || obj.Memcmp(q, name.S, len(name.S)) != 0 {
+	_ = q
+	if path.Clean(name.S) != name.S {
}
diff {
-	imp = obj.Bopen(namebuf, obj.OREAD)
-	if imp == nil {
+	var err error
+	imp, err = obj.Bopenr(namebuf)
+	if err != nil {
}
diff {
-		if p+10 != q {
+		if p[10:] != q {
}
diff {
-	if c >= main.Runeself {
+	if c >= utf8.RuneSelf {
}
diff {
-	cp = lexbuf
+	cp = &lexbuf
+	cp.Reset()
}
diff {
-	ep = lexbuf[sizeof(lexbuf):]
}
diff {
-			cp[0] = byte(c)
-			cp = cp[1:]
+			cp.WriteByte(byte(c))
}
diff {
-		lexbuf = "\"<string>\""
+		lexbuf.Reset()
+		lexbuf.WriteString(`"<string>"`)
}
diff {
-		lexbuf = "`<string>`"
+		lexbuf.Reset()
+		lexbuf.WriteString("`<string>`")
}
diff {
-		cp = string(make([]byte, 8))
-		clen = sizeof(int32)
-		ncp = 8
+		cp = &strbuf
+		cp.Reset()
}
diff {
-			if v < main.Runeself || escflag != 0 {
+			if v < utf8.RuneSelf || escflag != 0 {
}
diff {
-			if clen+main.UTFmax > ncp {
-				cp = remal(cp, int32(ncp), int32(ncp)).(string)
-				ncp += ncp
-			}
}
diff {
-				cp[clen] = byte(v)
-				clen++
+				cp.WriteByte(byte(v))
}
diff {
-				c = main.Runelen(rune_)
-				main.Runetochar(cp[clen:], &rune_)
-				clen += c
+				cp.WriteRune(rune(rune_))
}

diff {
-			rune_ = uint(c)
-			clen += main.Runetochar(cp[clen:], &rune_)
+			cp.WriteRune(rune(c))
}
diff {
-	*(*int32)(cp) = clen - sizeof(int32) // length
-	for {
-		cp[clen] = 0
-		clen++
-		if !(clen&MAXALIGN != 0) {
-			break
-		}
-	}
-
-	yylval.val.U.Sval = (*Strlit)(cp)
+	yylval.val.U.Sval = &Strlit{S: cp.String()}
}
diff {
-	var cp string
-	var ep string
+	var cp *bytes.Buffer
}
diff {
-var lexbuf string
+var lexbuf bytes.Buffer
+var strbuf bytes.Buffer
+
+func DBG(...interface{}){}
}
diff {
-		if cp[10:] >= ep {
-			Yyerror("identifier too long")
-			errorexit()
-		}
}
diff {
-			if cp[10:] >= ep {
-				Yyerror("identifier too long")
-				errorexit()
-			}
}
diff {
-		cp[0] = byte(c)
-		cp = cp[1:]
+		cp.WriteByte(byte(c))
}
diff {
-	cp = ""
+	cp = nil
}
diff {
-	ep = lexbuf[sizeof(lexbuf)-5:]
}
diff {
-		if cp < ep {
			cp.WriteByte(byte(c))
-		}
}
diff {
-			if !(main.Isalpharune(rune_) != 0) && !(main.Isdigitrune(rune_) != 0) && (importpkg == nil || rune_ != 0xb7) {
+			if !unicode.IsLetter(rune(rune_)) && !unicode.IsDigit(rune(rune_)) && (importpkg == nil || rune_ != 0xb7) {
}
diff {
-			cp = cp[main.Runetochar(cp, &rune_):]
+			cp.WriteRune(rune(rune_))
}
diff {
-	s = Lookup(lexbuf)
+	s = Lookup(lexbuf.String())
}
diff {
-	cp[0] = byte(c)
-	cp = cp[1:]
+	cp.WriteByte(byte(c))
}
diff {
-			if cp == lexbuf[2:] {
+			if lexbuf.Len() == 2 {
}
diff {
-, lexbuf)
+, lexbuf.String())
}
diff {
-	litbuf += lexbuf
+	litbuf += lexbuf.String()
}
diff {
-	var linep string
+	var linep int
	var h *obj.Hist
}
diff {
-	linep = ""
+	linep = 0
	for {
}
diff {
		if c == ':' {
-			linep = cp
+			linep = cp.Len()+1
		}
}
diff {
-		tmp.lit.S = tmp.lit.S[:len]
		tmp.lit.S = s
}
diff {
-func stringsym(s string, len int) *Sym {
+func stringsym(s string) *Sym {
}
diff {
-		off = dsname(sym, off, s[n:], m)
+		off = dsname(sym, off, s[n:n+m])
}
diff {
	// string data
-	for n = 0; n < len; n += m {
+	for n = 0; n < len(s); n += m {
		m = 8
-		if m > len-n {
+		if m > len(s)-n {
-			m = len - n
+			m = len(s) - n
		}
}
diff {
-func dsname(s *Sym, off int, t string, n int) int {
+func dsname(s *Sym, off int, t string) int {
	var p *obj.Prog

	p = Thearch.Gins(obj.ADATA, nil, nil)
	p.From.Type = obj.TYPE_MEM
	p.From.Name = obj.NAME_EXTERN
	p.From.Offset = int64(off)
	p.From.Sym = Linksym(s)
	p.From3.Type = obj.TYPE_CONST
-	p.From3.Offset = int64(n)
+	p.From3.Offset = int64(len(t))

	p.To.Type = obj.TYPE_SCONST
	p.To.U.Sval = t
	return off + n
}
diff {
-func Datastring(s string, len int, a *obj.Addr) {
+func Datastring(s string, a *obj.Addr) {
}
diff {
func Datastring(s string, a *obj.Addr) {
	var sym *Sym

-	sym = stringsym(s, int(len))
+	sym = stringsym(s)
}
diff {
func datagostring(sval *Strlit, a *obj.Addr) {
	var sym *Sym

-	sym = stringsym(sval.S, len(sval.S))
+	sym = stringsym(sval.S)
}
diff {
-	if linep == "" || linep >= ep {
+	if linep == 0 {
		goto out
	}
-	linep[0] = '\x00'
-	linep = linep[1:]
	n = 0
-	for cp = linep; cp[0] != 0; cp = cp[1:] {
+	for _, c := range lexbuf.String()[linep:] {
-		if cp[0] < '0' || cp[0] > '9' {
+		if c < '0' || c > '9' {
			goto out
		}
-		n = n*10 + int(cp[0]) - '0'
+		n = n*10 + int(c) - '0'
}
diff {
	// try to avoid allocating file name over and over
+	name = lexbuf.String()[:linep-1]
	for h = Ctxt.Hist; h != nil; h = h.Link {
-		if h.Name != "" && h.Name == lexbuf {
+		if h.Name != "" && h.Name == name {
			linehist(h.Name, int32(n), 0)
			goto out
		}
	}

-	linehist(lexbuf, int32(n), 0)
+	linehist(name, int32(n), 0)
}
diff {
-	ep = obj.Strchr(lexbuf, ' ')
-	if ep != "" {
-		ep = ""
-	}
+	cmd = lexbuf.String()
+	verb = cmd
+	if i := strings.Index(verb, " "); i >= 0 {
+		verb = verb[:i]
+	}
}
diff {
-	if lexbuf == "go:linkname" {
+	if verb == "go:linkname" {
}
diff {
-	if lexbuf == "go:nointerface" && obj.Fieldtrack_enabled != 0 {
+	if verb == "go:nointerface" && obj.Fieldtrack_enabled != 0 {
}
diff {
-	if lexbuf == "go:noescape" {
+	if verb == "go:noescape" {
}
diff {
-	if lexbuf == "go:nosplit" {
+	if verb == "go:nosplit" {
}
diff {
-	if lexbuf == "go:nowritebarrier" {
+	if verb == "go:nowritebarrier" {
}
diff {
+		f := strings.Fields(cmd)
-		if ep == "" {
+		if len(f) != 3 {
			Yyerror("usage: //go:linkname localname linkname")
			goto out
		}

-		cp = ep[1:]
-		for yy_isspace(int(cp[0])) {
-			cp = cp[1:]
-		}
-		ep = obj.Strchr(cp, ' ')
-		if ep == "" {
-			Yyerror("usage: //go:linkname localname linkname")
-			goto out
-		}
-
-		ep = ""
-		ep = ep[1:]
-		for yy_isspace(int(ep[0])) {
-			ep = ep[1:]
-		}
-		if ep[0] == 0 {
-			Yyerror("usage: //go:linkname localname linkname")
-			goto out
-		}
-
-		Lookup(cp).Linkname = ep
+		Lookup(f[1]).Linkname = f[2]
}

func getimpsym(pp *string) string {
	more(pp) // skip spaces
	p := *pp
	if p == "" || p[0] == '"' {
		return ""
	}
	i := 0
	for i < len(p) && !yy_isspace(int(p[i])) && p[i] != '"' {
		i++
	}
	sym := p[:i]
	*pp = p[i:]
	return sym
}

func getquoted(pp *string) (string, bool) {
	more(pp) // skip spaces
	p := *pp
	if p == "" || p[0] != '"' {
		return "", false
	}
	p = p[1:]
	i := strings.Index(p, `"`)
	if i < 0 {
		return "", false
	}
	*pp = p[i+1:]
	return p[:i], true
}
diff {
-		p = getquoted(&q)
-		if p == "" {
+		var ok bool
+		p, ok = getquoted(&q)
+		if !ok {
}
diff {
-		var ok bool
		p, ok = getquoted(&q)
		if !ok {
			goto err3
}
diff {
	if verb == "cgo_import_dynamic" || verb == "dynimport" {
+		var ok bool
}
diff {
-= obj.BGETC(curio.bin)
+= obj.Bgetc(curio.bin)
}

func getr() int32 {
	var buf [utf8.UTFMax]byte
	
	for i := 0;; i++ {
		c := getc()
		if i == 0 && c < utf8.RuneSelf {
			return int32(c)
		}
		buf[i] = byte(c)
		if i+1 == len(buf) || utf8.FullRune(buf[:i+1]) {
			r, w := utf8.DecodeRune(buf[:i+1])
			if r == utf8.RuneError && w == 1 {
				lineno = lexlineno
				Yyerror("illegal UTF-8 sequence % x", buf[:i+1])
			}
			return int32(r)
		}
	}
}
diff {
-	if u != 0 && (l > main.Runemax || (0xd800 <= l && l < 0xe000)) {
+	if u != 0 && (l > utf8.MaxRune || (0xd800 <= l && l < 0xe000)) {
}
diff {
-		l = main.Runeerror
+		l = utf8.RuneError
}

delete yytinit

diff {
-	elem = obj.Strrchr(path_.S, '/')
-
-	if elem != "" {
-		elem = elem[1:]
-	} else {
-		elem = path_.S
-	}
+	elem = path_.S
+	if i := strings.LastIndex(elem, "/"); i >= 0 {
+		elem = elem[i+1:]
+	}
}
diff {
	if outfile == "" {
-		p = obj.Strrchr(infile, '/')
-		if Ctxt.Windows != 0 {
-			q = obj.Strrchr(infile, '\\')
-			if q > p {
-				p = q
-			}
-		}
-
-		if p == "" {
-			p = infile
-		} else {
-			p = p[1:]
-		}
+		p = infile
+		if i := strings.LastIndex(p, "/"); i >= 0 {
+			p = p[i+1:]
+		}
+		if Ctxt.Windows != 0 {
+			if i := strings.LastIndex(p, `\`); i >= 0 {
+				p = p[i+1:]
+			}
+		}
-		namebuf = fmt.Sprintf("%s", p)
-		p = obj.Strrchr(namebuf, '.')
-		if p != "" {
-			p = ""
-		}
+		namebuf = p
+		if i := strings.LastIndex(namebuf, "."); i >= 0 {
+			namebuf = namebuf[:i]
+		}
}
diff {
-	yytinit()
+	// TODO(rsc): Restore yytinit?
}
diff {
-	cp[0] = 'g'
-	cp = cp[1:] // already read
+	cp.WriteByte('g') // already read
}
diff {
-		if c == EOF || c >= main.Runeself {
+		if c == EOF || c >= utf8.RuneSelf {
}
diff {
-		pragcgo(lexbuf)
+		pragcgo(lexbuf.String())
}
diff {
-	for q = text; q[0] != '\x00' && q[0] != ' '; q = q[1:] {
-	}
-	if q[0] == ' ' {
-		q[0] = '\x00'
-		q = q[1:]
-	}
+	if i := strings.Index(text, " "); i >= 0 {
+		text, q = text[:i], text[i:]
+	}
}
diff {
-	if strings.HasPrefix(lexbuf, "go:cgo_") {
+	if strings.HasPrefix(lexbuf.String(), "go:cgo_") {
}
diff {
-	graph = obj.Calloc(sizeof(*graph)+sizeof(Flow)*nf+size*nf, 1).(*Graph)
-
-	if graph == nil {
-		Fatal("out of memory")
-	}
-	start = (*Flow)(graph + 1)
-	last = nil
-	f = start
-	data = string(f + nf)
-	if size == 0 {
-		data = ""
-	}
+	graph = new(Graph)
+	ff := make([]Flow, nf)
+	start = &ff[0]
}
diff {
+		f := &ff[0]
+		ff = ff[1:]
		p.Opt = f
		f.Prog = p
		if last != nil {
			last.Link = f
		}
		last = f
-		f.Data = data
+		if newData != nil {
+			f.Data = newData()
+		}
		f.Id = int32(id)
-		f++
		id++
-		data = data[size:]
}
diff {
	// Build list of all mergeable variables.
-	var_ = var_[:0]
-
+	nvar = 0
	for l = Curfn.Dcl; l != nil; l = l.Next {
		if canmerge(l.N) != 0 {
-			len(var_)++
+			nvar++
		}
	}

-	var_ = obj.Calloc(len(var_)*sizeof(var_[0]), 1).([]TempVar)
-	var_ = var_[:0]
+	var_ = make([]TempVar, nvar)
+	nvar = 0
}
diff {
-			v = &var_[len(var_)]
-			len(var_)++
+			v = &var_[nvar]
+			nvar++
}
diff {
-func Flowstart(firstp *obj.Prog, size int) *Graph {
+func Flowstart(firstp *obj.Prog, newData func() interface{}) *Graph {
}
diff {
-	g.Rpo = obj.Calloc(g.Num*sizeof(g.Rpo[0]), 1).([]*Flow)
-	idom = obj.Calloc(g.Num*sizeof(idom[0]), 1).([]int32)
-	if g.Rpo == nil || idom == nil {
-		Fatal("out of memory")
-	}
+	g.Rpo = make([]*Flow, g.Num)
+	idom = make([]int32, g.Num)
}
diff {
-Flowstart(firstp, 0)
+Flowstart(firstp, nil)
}
diff {
-	for z = 0; z < main.BITS; z++ {
+	for z = 0; z < BITS; z++ {
}
diff {
-	if nreg == 64 {
-		mask = ^0 // can't rely on C to shift by 64
-	} else {
-		mask = (1 << uint(nreg)) - 1
-	}
+	mask = (1 << uint(nreg)) - 1
}
diff {
-	if nvar >= main.NVAR {
+	if nvar >= NVAR {
}
diff {
+func LOAD(r *Reg, z int) uint64 {
+	return ^r.refbehind.b[z] & r.refahead.b[z]
+}
+
+func STORE(r *Reg, z int) uint64 {
+	return ^r.calbehind.b[z] & r.calahead.b[z]
+}
+
func paint1(f *Flow, bn int) {
}

diff {
-	if LOAD(r)&^(r.set.b[z]&^(r.use1.b[z]|r.use2.b[z]))&bb != 0 {
+	if LOAD(r, z)&^(r.set.b[z]&^(r.use1.b[z]|r.use2.b[z]))&bb != 0 {
}
diff {
-		if STORE(r)&r.regdiff.b[z]&bb != 0 {
+		if STORE(r, z)&r.regdiff.b[z]&bb != 0 {
}
diff {
-		obj.Fmtinstall('Q', Qconv)
}

slice Arch.regnames.return
slice regopt.regnames
diff {
-	g = Flowstart(firstp, sizeof(Reg))
+	g = Flowstart(firstp, func()interface{}{return new(Reg)})
}
diff {
-			bit.b[z] = LOAD(r) &^ (r.act.b[z] | addrs.b[z])
+			bit.b[z] = LOAD(r, z) &^ (r.act.b[z] | addrs.b[z])
}
diff {
-	s = path_.S
-	for s[0] != 0 {
-		s = s[main.Chartorune(&r, s):]
+	_ = s
+	_ = r
+	for _, r := range path_.S {
-		if r == main.Runeerror {
+		if r == utf8.RuneError {
}
diff {
func tostr(v Val) Val {
	var rune_ uint
-	var l int
}
diff {
func Zconv(sp *Strlit, flag int) string {
	var fp string
-
	var s string
-	var se string
}
diff {
func Main() {
-	var i int
}
diff {
func _yylex() int32 {
	var c int
	var c1 int
-	var clen int
	var escflag int
-	var ncp int
}
diff {
func mkpackage(pkgname string) {
	var s *Sym
	var h int32
	var p string
-	var q string
}
diff {
func Flowstart(firstp *obj.Prog, newData func() interface{}) *Graph {
	var id int
	var nf int
	var f *Flow
	var f1 *Flow
	var start *Flow
	var last *Flow
	var graph *Graph
	var p *obj.Prog
	var info ProgInfo
-	var data string
}
diff {
func Yyerror(fmt_ string, args ...interface{}) {
	var i int
-	var buf string
-	var p string
}

export warn
diff {
func Warn(fmt_ string, args ...interface{}) {
-	var arg []interface{}
}

diff {
-	var nhash uint32
	var autohash [101]*Node
}
diff {
func bvcmp(bv1 *Bvec, bv2 *Bvec) int {
-	var nbytes uint32
-
	if bv1.n != bv2.n {
		Fatal("bvequal: lengths %d and %d are not equal", bv1.n, bv2.n)
	}
-	nbytes = bvsize(uint32(bv1.n))
}
diff {
		goto none

+	memcase:
+		fallthrough
+
	case obj.TYPE_MEM:
-	memcase:
}
diff {
func getlinepragma() int {
+	var cmd, verb, name string
}

export Arch
export ostats
export Optstats

slice regnames.return

diff {
-	x86.Listinit6()
}
diff {
-	gc.Gcmain(argc, [XXX]string(argv))
+	gc.Main()
}
diff {
-func main(argc int, argv *string) {
+func main() {
}
diff {
-	gc.Typedef{0, 0, 0},
}
diff {
-// Matches real RtoB but can be used in global initializer.
-const (
+var (
}
diff {
-	LeftRdwr  = gc.LeftRead | gc.LeftWrite
-	RightRdwr = gc.RightRead | gc.RightWrite
+	LeftRdwr  uint32 = gc.LeftRead | gc.LeftWrite
+	RightRdwr uint32 = gc.RightRead | gc.RightWrite
}

bool bgen.true

diff {
-	Bgen           func(*Node, int, int, *obj.Prog)
+	Bgen           func(*Node, bool, int, *obj.Prog)
}

bool complexbool.true

diff {
-		Thearch.Bgen(cmp, 1, -1, p2)
+		Thearch.Bgen(cmp, true, -1, p2)
}
diff {
-		Thearch.Bgen(n.Ntest, 0, -1, breakpc) //		if(!test) goto break
+		Thearch.Bgen(n.Ntest, false, -1, breakpc) //		if(!test) goto break
}
diff {
-		Thearch.Bgen(n.Ntest, 0, int(-n.Likely), p2) //		if(!test) goto p2
+		Thearch.Bgen(n.Ntest, false, int(-n.Likely), p2) //		if(!test) goto p2
}
diff {
-	Thearch.Bgen(&na, bool2int(true_), likely, to)
+	Thearch.Bgen(&na, true_, likely, to)
}

diff {
-func _yylex() int32 {
+func _yylex(yylval *yySymType) int32 {
}
diff {
+type yy struct{}
+
+var yymsg []struct{yystate, yychar int; msg string}
+
+func (yy) Lex(v *yySymType) int {
+	return int(yylex(v))
+}
+
+func (yy) Error(msg string) {
+	Yyerror("%s", msg)
+}
+
+func yyparse() {
+	yyParse(yy{})
+}
+
-func yylex() int32 {
+func yylex(yylval *yySymType) int32 {
}
diff {
-	lx = int(_yylex())
+	lx = int(_yylex(yylval))
}

bool isblanksym.return
func isblanksym(s *Sym) bool {
	return s != nil && s.Name == "_"
}

bool isblank.return
bool isbadimport.return
bool noescape
bool nointerface
bool isptr.return
bool Io.importsafe
bool Pkg.safe
bool Node.noescape
bool Node.nosplit
bool Node.nowritebarrier
bool nosplit
bool nowritebarrier
bool Node.nointerface
bool eqtype.return
bool addmethod.local
bool addmethod.nointerface

diff {
-		c = int(p[0])
-		p = p[1:]
+		c, p = intstarstringplusplus(p)
}
diff {
-	c = int(s[0])
-	s = s[1:]
+	c, s = intstarstringplusplus(s)
}
diff {
-		c = int(s[0])
-		s = s[1:]
+		c, s = intstarstringplusplus(s)
}
diff {
-			c = int(s[0])
-			s = s[1:]
+			c, s = intstarstringplusplus(s)
}
diff {
-				c = int(s[0])
-				s = s[1:]
+				c, s = intstarstringplusplus(s)
}
diff {
-	c = int(s[0])
+	c, _ = intstarstringplusplus(s)
}
diff {
-	for i = 0; Thearch.Typedefs[i].Name != ""; i++ {
+	for i = range Thearch.Typedefs {
}
diff {
-		c = int(curio.cp[0]) & 0xff
-		if c != 0 {
+		if len(curio.cp) == 0 {
+			c = 0
+		} else {
+			c = int(curio.cp[0])
}

diff {
-var alive interface{}
-
-var dead interface{}
+var alive interface{} = nil
+var dead interface{} = 1
}
diff {
- v = n.Opt.(*TempVar)
+ v, _ = n.Opt.(*TempVar)
}
diff {
- n = p.From.Node.(*Node)
+ n, _ = p.From.Node.(*Node)
}
diff {
- n = p.To.Node.(*Node)
+ n, _ = p.To.Node.(*Node)
}
diff {
- v.nextinnode = node.Opt.(*Var)
+ v.nextinnode, _ = node.Opt.(*Var)
}
diff {
- v1 = v.node.Opt.(*Var)
+ v1, _ = v.node.Opt.(*Var)
}
diff {
- for v = n.Opt.(*Var); v != nil; v = v.nextinnode {
+ for v, _ = n.Opt.(*Var); v != nil; v = v.nextinnode {
}

func more(pp *string) bool {
	p := *pp
	for p != "" && yy_isspace(int(p[0])) {
		p = p[1:]
	}
	*pp = p
	return p != ""
}

diff {
-				pos = int32(int(((from.Node).(*Node)).Opt.(uint32))) - 1 // index in vars
-				if pos == -1 {
+				pos, ok := from.Node.(*Node).Opt.(int32) // index in vars
+				if !ok {
}
diff {
-				pos = int32(int(((to.Node).(*Node)).Opt.(uint32))) - 1 // index in vars
-				if pos == -1 {
+				pos, ok := to.Node.(*Node).Opt.(int32) // index in vars
+				if !ok {
}
diff {
-	ll.N.Opt = interface{}(uint32(len(result) + 1))
+	ll.N.Opt = int32(len(result))
}

diff {
func progeffects(prog *obj.Prog, vars []*Node, uevar *Bvec, varkill *Bvec, avarinit *Bvec) {
	var info ProgInfo
	var from *obj.Addr
	var to *obj.Addr
	var node *Node
	var i int32
-	var pos int32
}

diff {
-	node = a.Node.(*Node)
+	node, _ = a.Node.(*Node)
}

bool haspointers.return

delete Strlit.len

diff {
-	if len > 100 {
+	if len(s) > 100 {
		// huge strings are made static to avoid long names
}
diff {
	// string header
	off = dsymptr(sym, off, sym, Widthptr+Widthint)
-
-	off = duintxx(sym, off, uint64(len), Widthint)
+	off = duintxx(sym, off, uint64(len(s)), Widthint)
}

string Strlit.s Strlit.len

diff {
-				l2 = l1
-				len = 0
-				for l2 != nil && Isconst(l2.N, CTSTR) != 0 {
-					nr = l2.N
-					len += len(nr.Val.U.Sval.S)
-					l2 = l2.Next
-				}
-
				// merge from l1 up to but not including l2
-				str = (*Strlit)(make([]byte, sizeof(*str)+len))
-
+				str = new(Strlit)
-				str.S = str.S[:len]
-				len = 0
				l2 = l1
				for l2 != nil && Isconst(l2.N, CTSTR) != 0 {
					nr = l2.N
					str.S += nr.Val.U.Sval.S
-					len += len(nr.Val.U.Sval.S)
					l2 = l2.Next
				}
}
diff {
-	Datastring(str, len(str)+1, &p.To)
+	Datastring(str+"\x00", &p.To) // TODO(rsc): Remove NUL
}
diff {
-	Datastring(sval.S, len(sval.S), &p.To)
+	Datastring(sval.S, &p.To)
}
diff {
	p.To.U.Sval = t
-	return off + n
+	return off + len(t)
}
diff {
-		if len(p.Path.S) == len(path_.S) && obj.Memcmp(path_.S, p.Path.S, len(path_.S)) == 0 {
+		if p.Path.S == path_.S {
}
diff {
-	var len int32
	var str *Strlit
}
diff {
-			gc.Datastring(nl.Val.U.Sval.S, len(nl.Val.U.Sval.S), &p1.From)
+			gc.Datastring(nl.Val.U.Sval.S, &p1.From)
}
diff {
-		linehist("", 0, 0)
+		linehist("<pop>", 0, 0)
}

diff {
- fmt.Sprintf("$\"%q\"", a.U.Sval)
+ fmt.Sprintf("$%q", a.U.Sval)
}
diff {
-	if s.Name != "" && s.Name[0] == '_' && s.Name[1] == '\x00' {
+	if s.Name == "_" {
}
diff {
- mphextofix(&a.Val, start)
+ mphextofix(&a.Val, start[:len(start)-len(s)])
}
diff {
		case '0':
-			if s[0] == 'x' {
+			if s != "" && s[0] == 'x' {
				base = 16
}
diff {
	for base == -1 {
+		if s == "" {
+			base = 10
+			break
+		}
-		tmp8 := s
+		c := s[0]
		s = s[1:]
-		switch tmp8[0] {
+		switch c {
}

export eqtype noconv

diff {
-		gmove(ncon(-1), &t1)
+		gmove(ncon(^uint32(0)), &t1)
}

export mpmovecfix

diff {
-	arm.Listinit5()
}
diff {
-	i386.Listinit8()
}
diff {
-	ppc64.Listinit9()
}

export mpmovecflt
export use_sse

diff {
-				obj.Memmove(&varianttable[varianttable[i][j]], &varianttable[i], sizeof(varianttable[i]))
+				varianttable[varianttable[i][j]] = varianttable[i]
}
diff {
-			gins(i386.ACMPL, &t1, ncon(-0x80))
+			gins(i386.ACMPL, &t1, ncon(-0x80 & (1<<32-1)))
}
diff {
-			gmove(ncon(-0x80), &t1)
+			gmove(ncon(-0x80 & (1<<32-1)), &t1)
}

func memname(n *gc.Node, t *gc.Type) {
	gc.Tempname(n, t)
	n.Sym = gc.Lookup("."+n.Sym.Name[1:]) // keep optimizer from registerizing
	n.Orig.Sym = n.Sym
}

export lookup

diff {
-var ELF_NOTE_NETBSD_NAME string = "NetBSD\0\0"
+var ELF_NOTE_NETBSD_NAME string = "NetBSD\x00\x00"
}
diff {
-var ELF_NOTE_OPENBSD_NAME string = "OpenBSD\0"
+var ELF_NOTE_OPENBSD_NAME string = "OpenBSD\x00"
}
diff {
-var ELF_NOTE_BUILDINFO_NAME string = "GNU\0"
+var ELF_NOTE_BUILDINFO_NAME string = "GNU\x00\x00"
}
diff {
-	Cwrite("\0\0\0", int(Rnd(int64(buildinfolen), 4) - int64(buildinfolen)))
+	Cwrite("\x00\x00\x00", int(Rnd(int64(buildinfolen), 4) - int64(buildinfolen)))
}
diff {
-obj.Qsort(r, rp-r, sizeof(r[0]), rbyoff)
+sort.Sort(rbyoff(r[:cap(r)-cap(rp)]))
}
diff {
-obj.Qsort(r, rsect.sh.NumberOfRelocations, sizeof(r[0]), rbyoff)
+sort.Sort(rbyoff(r[:rsect.sh.NumberOfRelocation]))
}

export adduint8 addaddr addaddrplus addsize addaddrplus4 adduintxx linkrlookup

diff {
-var dosstub = []int8{
+var dosstub = []uint8{
}
diff {
-			i16 = int16(o)
-			cast = []byte(&i16)
-			for i = 0; i < 2; i++ {
-				s.P[off+i] = cast[obj.Inuxi2[i]]
-			}
+			Thearch.ByteOrder.PutUint16(s.P[off:], uint16(o))
}
diff {
-			fl = int32(o)
-			cast = []byte(&fl)
-			for i = 0; i < 4; i++ {
-				s.P[off+i] = cast[obj.Inuxi4[i]]
-			}
+			Thearch.ByteOrder.PutUint32(s.P[off:], uint32(o))
}
diff {
-			cast = []byte(&o)
-			for i = 0; i < 8; i++ {
-				s.P[off+i] = cast[obj.Inuxi8[i]]
-			}
+			Thearch.ByteOrder.PutUint64(s.P[off:], uint64(o))
}

func decode_inuxi(p []byte, sz int) uint64 {
	switch sz {
	case 2:
		return uint64(Thearch.ByteOrder.Uint16(p))
	case 4:
		return uint64(Thearch.ByteOrder.Uint32(p))
	case 8:
		return uint64(Thearch.ByteOrder.Uint64(p))
	}
	Diag("dwarf: decode inuxi %d", sz)
	Errorexit()
	panic("not reached")
}

diff {
type Arch struct {
+	ByteOrder binary.ByteOrder
}

diff {
-	obj.Memmove(s.P[r:], str, n)
+	copy(s.P[r:], str)
+	s.P[int(r)+len(str)] = 0
}

func xuleb128put(sv int64) {
	v := uint64(sv)
	for {
		c := uint8(v & 0x7F)
		v >>= 7
		if v != 0 {
			c |= 0x80
		}
		cput(c)
		if c&0x80 == 0 {
			break
		}
	}
}

func xsleb128put(v int64) {
	for {
		c := uint8(v & 0x7F)
		s := uint8(v & 0x40)
		v >>= 7
		if (v != -1 || s == 0) && (v != 0 || s != 0) {
			c |= 0x80
		}
		cput(c)
		if c&0x80 == 0 {
			break
		}
	}
}

diff {
-func uleb128enc(v uint64, dst string) int {
+func uleb128enc(v uint64, dst []byte) int {
}

diff {
-func sleb128enc(v int64, dst string) int {
+func sleb128enc(v int64, dst []byte) int {
}

diff {
-		if dst != "" {
-			dst[0] = byte(c)
+		if dst != nil {
+			dst[0] = byte(c)
}

func uleb128put(v int64) {
	var buf [16]byte
	Bwrite(cout, buf[:uleb128enc(uint64(v), buf[:])])
}

func sleb128put(v int64) {
	var buf [16]byte
	Bwrite(cout, buf[:sleb128enc(v, buf[:])])
}

slice load nload mload
slice MachoLoad.data MachoLoad.ndata
export pciter pciterinit ldobjfile headtype atolwhex adduint16 setuint32 setuint8 setaddr pciternext
slice dd
export Pciter Pcdata
slice elfstrdat elfstrsize maxelfstr
export elfstrdat
slice Elfstrdat elfstrsize maxelfstr
delete maxelfstr
delete elfstrsize
delete nlaod mload

func putelfstr(s string) int {
	if len(Elfstrdat) == 0 && s != "" {
		// first entry must be empty string
		putelfstr("")
	}
	
	// replace  with . for DTrace
	s = strings.Replace(s, "", ".", -1)

	off := len(Elfstrdat)
	Elfstrdat = append(Elfstrdat, s...)
	return off
}

diff {
-var Elfstrdat string
+var Elfstrdat []byte
}

diff {
-		fmt.Fprintf(&Bso, "%d sizeof adr\n", sizeof(obj.Addr))
-		fmt.Fprintf(&Bso, "%d sizeof prog\n", sizeof(obj.Prog))
}

diff {
-	obj.Addlibpath(Ctxt, "command line", "command line", argv[0], "main")
+	obj.Addlibpath(Ctxt, "command line", "command line", flag.Arg(0), "main")
}

export addlibpath

diff {
-	cbp = buf.cbuf
-	cbp = cbp[:sizeof(buf.cbuf)]
+	cbp = buf.cbuf[:]
}
diff {
-	cbuf string
+	cbuf [8192]byte
}
diff {
-	obj.Flagparse(&argc, &argv, usage)
+	obj.Flagparse(usage)
}
diff {
-	if argc != 1 {
+	if flag.NArg() != 1 {
}

slice cbp cbc cbpmax

diff {
-var cbp string
+var cbp []byte
}
delete cbc cbpmax

diff {
-	for i = 1; i < argc; i++ {
-		if argv[i] == "-crash_for_testing" {
+	for _, arg := range os.Args {
+		if arg == "-crash_for_testing" {
}

diff {
-	obj.Binit(&Bso, 1, obj.OWRITE)
+	Bso = *obj.Binitw(os.Stdout)
}

slice strtbl strtblnextoff strtblsize

func strtbladd(name string) int {
	// TODO(rsc): Okay, first string starts at offset 4.
	// Why do we put 4 bytes before EVERY string?
	strtbl = append(strtbl, 0, 0, 0, 0) // first string starts at offset=4
	off := len(strtbl)
	strtbl = append(strtbl, name...)
	strtbl = append(strtbl, 0)
	return off
}

diff {
-var strtbl string
+var strtbl []byte
}
diff {
-	obj.Strncpy(string(h.Name), name, len((h.Name)))
+	copy(h.Name[:], name)
}

slice findfunctab.indexes
export setaddrplus

slice renumberfiles.files renumberfiles.nfiles

diff {
-func Cwrite(buf interface{}, n int) {
+func Cwrite(buf []byte) {
	Cflush()
-	if n <= 0 {
+	if len(buf) == 0 {
		return
	}
-	dowrite(cout, buf.(string), n)
+	dowrite(cout, buf)
-	coutpos += int64(n)
+	coutpos += int64(len(buf))
}

diff {
-	Cwrite(rsrcsym.P, int(rsrcsym.Size))
+	Cwrite(rsrcsym.P[:rsrcsym.Size])
}
diff {
-		Cwrite(sh[i].Name, 8)
+		Cwrite(sh[i].Name[:8])
}
diff {
-		Diag("%s.PointerToRawData = %#x, want %#x", string(h.Name), uint64(int64(h.PointerToRawData)), uint64(off))
+		Diag("%s.PointerToRawData = %#x, want %#x", cstring(h.Name[:]), uint64(int64(h.PointerToRawData)), uint64(off))
}
diff {
-		Diag("%s.VirtualAddress = %#x, want %#x", string(h.Name), uint64(int64(h.VirtualAddress)), uint64(int64(s.Vaddr-PEBASE)))
+		Diag("%s.VirtualAddress = %#x, want %#x", cstring(h.Name[:]), uint64(int64(h.VirtualAddress)), uint64(int64(s.Vaddr-PEBASE)))
}
diff {
-		Diag("%s.PointerToRawData = %#x, want %#x", string(h.Name), uint64(int64(h.PointerToRawData)), uint64(int64(s.Fileoff)))
+		Diag("%s.PointerToRawData = %#x, want %#x", cstring(h.Name[:]), uint64(int64(h.PointerToRawData)), uint64(int64(s.Fileoff)))
}
diff {
-
-	indexes = []int32((*int32)(make([]byte, 4)))
-	if indexes == nil {
-		Diag("out of memory")
-		Errorexit()
-	}
+	indexes = make([]int32, n)
}

diff {
-			renumberfiles(Ctxt, pcln.File, (*obj.Pcdata)(len(pcln.File)), &pcln.Pcfile)
+			renumberfiles(Ctxt, pcln.File, &pcln.Pcfile)
}
diff {
-func renumberfiles(ctxt *obj.Link, files **obj.LSym, nfiles int, d *obj.Pcdata) {
+func renumberfiles(ctxt *obj.Link, files []*obj.LSym, d *obj.Pcdata) {
}

func ftabaddstring(ftab *obj.LSym, s string) int32 {
	n := len(s)+1
	start := len(ftab.P)
	obj.Symgrow(Ctxt, ftab, int64(start+n+1))
	copy(ftab.P[start:], s)
	return int32(start)
}

diff {
// ld

-func addvarint(ctxt *Link, d *Pcdata, val uint32) {
+func addvarint(d *obj.Pcdata, val uint32) {
}

func addpctab(ftab *obj.LSym, off int32, d *obj.Pcdata) int32 {
	start := len(ftab.P)
	obj.Symgrow(Ctxt, ftab, int64(start+len(d.P)))
	copy(ftab.P[start:], d.P)
	return int32(obj.Setuint32(Ctxt, ftab, int64(off), uint32(start)))
}

diff {
-		Cwrite(s1.P, int(s1.Size))
-		Cwrite(s2.P, int(s2.Size))
-		Cwrite(s3.P, int(s3.Size))
-		Cwrite(s4.P, int(s4.Size))
+		Cwrite(s1.P[:s1.Size])
+		Cwrite(s2.P[:s2.Size])
+		Cwrite(s3.P[:s3.Size])
+		Cwrite(s4.P[:s4.Size])
}

diff {
type MachoLoad struct {
	type_ uint32
-	ndata uint32
-	data  *uint32
+	data []uint32
}

slice dylib ndylib
delete ndylib

diff {
-	if len(dylib)%32 == 0 {
-		dylib = obj.Erealloc(dylib, (len(dylib)+32)*sizeof(dylib[0])).([]string)
-	}
-	dylib[len(dylib)] = lib
-	len(dylib)++
+	dylib = append(dylib, lib)
}

diff {
-	var l *MachoLoad
-
-	if len(load) >= cap(load) {
-		if cap(load) == 0 {
-			cap(load) = 1
-		} else {
-			cap(load) *= 2
-		}
-		load = obj.Erealloc(load, cap(load)*sizeof(load[0])).([]MachoLoad)
-	}
-
	if macho64 != 0 && (ndata&1 != 0) {
		ndata++
	}

-	l = &load[len(load)]
-	len(load)++
+	load = append(load, MachoLoad{})
+	l := &load[len(load)-1]
}

diff {
	var buf string
	var tn string
	var sep string
-	var arg []interface{}
}

diff {
-	obj.Va_start(arg, fmt_)
-	obj.Vseprint(buf, buf[sizeof(buf):], fmt_, arg)
-	obj.Va_end(arg)
+	buf = fmt.Sprintf(fmt_, args...)
	fmt.Printf("%s%s%s\n", tn, sep, buf)
}

diff {
-		return obj.Atolwhex(a)
+		x, _ := strconv.ParseInt(a, 0, 64)
+		return x
}

rename obj xobj

func Cwrite(b []byte) {
	obj.Bwrite(cout, b)
}

func Cput(c uint8) {
	obj.Bputc(cout, c)
}

bool haslinkregister.return

delete unmal hunk nhunk NHUNK pathchar

export ldobjfile

diff {
-	line = obj.Brdline(f, '\n').(string)
+	line = obj.Brdline(f, '\n')
-
}
diff {
	n = obj.Blinelen(f) - 1
-	line[n] = '\x00'
+	oldline := line
+	line = line[:n]
}
diff {
-	line[n] = ' '
-	if !strings.HasPrefix(line+10, t) && !(Debug['f'] != 0) {
-		line[n] = '\x00'
+	if !strings.HasPrefix((line+" ")[10:], t) && Debug['f'] == 0 {
}
diff {
	// Second, check that longer lines match each other exactly,
	// so that the Go compiler and write additional information
	// that must be the same from run to run.
-	line[n] = '\x00'
-
}
diff {
		if theline == "" {
			theline = line[10:]
-		} else if theline != line+10 {
-			line[n] = '\x00'
+		} else if theline != line[10:] {
}
diff {
-	line[n] = '\n'
+	line = oldline
}
diff {
-		if len(pn) > 3 && pn+(obj.Strlen(pn)-3) == ".go" {
+		if strings.HasSuffix(pn, ".go") {
}
diff {
-	p = extldflags
-	for p != "" {
-		for p[0] == ' ' {
-			p[0] = '\x00'
-			p = p[1:]
-		}
-		if p[0] == '\x00' {
-			break
-		}
-		argv[argc] = p
-		argc++
+	for _, p := range strings.Fields(extldflags) {
+		argv = append(argv, p)
}
diff {
-		if Iself != 0 && strings.HasPrefix(p, "-static") && (p[7] == ' ' || p[7] == '\x00') {
+		if Iself != 0 && p == "-static" {
}
diff {
-
-		p = obj.Strchr(p[1:], ' ')
	}
-
-	argv[argc] = ""
}

diff {
-	argv[argc] = fmt.Sprintf("%s/go.o", tmpdir)
-	argc++
-	for i = 0; i < len(ldflag); i++ {
-		argv[argc] = ldflag[i]
-		argc++
-	}
+	argv = append(argv, fmt.Sprintf("%s/go.o", tmpdir))
+	argv = append(argv, ldflag...)
}

slice ldflag nldflag
delete nldflag

diff {
		p = fmt.Sprintf("%s/%06d.o", tmpdir, i)
-		argv[argc] = p
-		argc++
+		argv = append(argv, p)
}
diff {
-		argv[argc] = "-Qunused-arguments"
-		argc++
+		argv = append(argv, "-Qunused-arguments")
}
diff {
-		argv[argc] = "-rdynamic"
-		argc++
+		argv = append(argv, "-rdynamic")
}
diff {
-		argv[argc] = fmt.Sprintf("-Wl,-rpath,%s", rpath)
-		argc++
+		argv = append(argv, fmt.Sprintf("-Wl,-rpath,%s", rpath))
}
diff {
-	argv[argc] = "-o"
-	argc++
-	argv[argc] = outfile
-	argc++
+	argv = append(argv, "-o", outfile)
}
diff {
-		argv[argc] = "-Wl,-Bsymbolic"
-		argc++
-		argv[argc] = "-shared"
-		argc++
+		argv = append(argv, "-Wl,-Bsymbolic", "-shared")
}
diff {
-		argv[argc] = "-Wl,--rosegment"
-		argc++
+		argv = append(argv, "-Wl,--rosegment")
}
diff {
-		argv[argc] = "-Wl,-nopie"
-		argc++
+		argv = append(argv, "-Wl,-nopie")
}
diff {
-		argv[argc] = "-Wl,-no_pie,-pagezero_size,4000000"
-		argc++
+		argv = append(argv, "-Wl,-no_pie,-pagezero_size,4000000")
}
diff {
-		argv[argc] = "-s"
-		argc++
+		argv = append(argv, "-s")
}
diff {
-		argv[argc] = "-gdwarf-2"
-		argc++
+		argv = append(argv, "-gdwarf-2")
}
diff {
-		argv[argc] = "-marm"
-		argc++
+		argv = append(argv, "-marm")
}
diff {
-		argv[argc] = "-m64"
-		argc++
+		argv = append(argv, "-m64")
}
diff {
-		argv[argc] = "-m32"
-		argc++
+		argv = append(argv, "-m32")
}
diff {
-	argv[argc] = extld
-	argc++
+	argv = append(argv, extld)
}
diff {
-	c = 0
-	p = extldflags
-	for p != "" {
-		for p[0] == ' ' {
-			p = p[1:]
-		}
-		if p[0] == '\x00' {
-			break
-		}
-		c++
-		p = obj.Strchr(p[1:], ' ')
-	}
-
-	argv = make([]string, (14 + len(hostobj) + len(ldflag) + c))
-	argc = 0
}
diff {
	var n int
-	var argc int
	var len int
}

delete gethunk
diff {
-		for i = 0; i < argc; i++ {
-			fmt.Fprintf(&Bso, " %v", plan9quote(argv[i]))
+		for _, arg := range argv {
+			fmt.Fprintf(&Bso, " %v", plan9quote(arg))
		}
}
diff {
-		f = obj.Bopen(h.file, obj.OREAD)
-		if f == nil {
+		var err error
+		f, err = obj.Bopenr(h.file)
+		if err != nil {
}
diff {
-	removeall(tmpdir)
+	os.RemoveAll(tmpdir)
}

slice hostobj nhostobj mhostobj
delete nhostobj mhostobj

delete dowrite

diff {
-	f = obj.Bopen(file, 0)
+	f = obj.Bopenr(file)
}
diff {
-	l = int64(obj.Bread(f, magbuf, obj.SARMAG))
-	if l != obj.SARMAG || !strings.HasPrefix(magbuf, obj.ARMAG) {
+	obj.Bread(f, magbuf[:])
+	if string(magbuf[:]) != obj.ARMAG {
}
diff {
-	var magbuf string
+	var magbuf [len(obj.ARMAG)]byte
}

delete ldobjfile readsym rdint rdstring rddata rdsym # for now
bool iself

func symlistsort(l *obj.LSym, cmp func(x, y *obj.LSym) int, next func(*obj.LSym) **obj.LSym) *obj.LSym {
	var l1 *obj.LSym
	var l2 *obj.LSym
	var le *obj.LSym

	if l == nil || *next(l) == nil {
		return l
	}

	l1 = l
	l2 = l
	for {
		l2 = *next(l2)
		if l2 == nil {
			break
		}
		l2 = *next(l2)
		if l2 == nil {
			break
		}
		l1 = *next(l1)
	}

	l2 = *next(l1)
	*next(l1) = nil
	l1 = symlistsort(l, cmp, next)
	l2 = symlistsort(l2, cmp, next)

	/* set up lead element */
	if cmp(l1, l2) < 0 {
		l = l1
		l1 = *next(l1)
	} else {
		l = l2
		l2 = *next(l2)
	}

	le = l

	for {
		if l1 == nil {
			for l2 != nil {
				*next(le) = l2
				le = l2
				l2 = *next(l2)
			}
			*next(le) = nil
			break
		}

		if l2 == nil {
			for l1 != nil {
				*next(le) = l1
				le = l1
				l1 = *next(l1)
			}

			break
		}

		if cmp(l1, l2) < 0 {
			*next(le) = l1
			le = l1
			l1 = *next(l1)
		} else {
			*next(le) = l2
			le = l2
			l2 = *next(l2)
		}
	}
	*next(le) = nil
	return l
}

diff {
-	datap = symlistsort(datap, datcmp, offsetof(obj.LSym, next))
+	if datap != nil {
+		datap = symlistsort(datap, datcmp, func(x *obj.LSym) **obj.LSym { return &x.Next })
+	}
}
diff {
-	s.Sub = symlistsort(s.Sub, valuecmp, offsetof(obj.LSym, sub))
+	s.Sub = symlistsort(s.Sub, valuecmp, func(x *obj.LSym) **obj.LSym { return &x.Sub })
}

slice dynexp ndynexp
delete ndynexp

diff {
-	if Runcmd(&argv[0]) < 0 {
+	out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput()
+	if err != nil {
		Ctxt.Cursym = nil
-		Diag("%s: running %s failed: %v", argv0, argv[0], err)
+		Diag("%s: running %s failed: %v\n%s", argv0, argv[0], err, out)
}

diff {
-		var err error
-		f, err = obj.Bopenr(h.file)
+		f, err := os.Open(h.file)
		if err != nil {
			Ctxt.Cursym = nil
			Diag("cannot reopen %s: %v", h.pn, err)
			Errorexit()
		}

-		obj.Bseek(f, h.off, 0)
+		if _, err := f.Seek(h.off, 0); err != nil {
+			Ctxt.Cursym = nil
+			Diag("cannot reread %s: %v", h.pn, err)
+			Errorexit()
+		}
		p = fmt.Sprintf("%s/%06d.o", tmpdir, i)
		argv = append(argv, p)
-		w = obj.Create(p, 1, 0775)
-		if w < 0 {
+		w, err := os.Create(p)
+		if err != nil {
			Ctxt.Cursym = nil
			Diag("cannot create %s: %v", p, err)
			Errorexit()
		}

-		size = int(h.len)
-		for size > 0 && n > 0 {
-			if n > size {
-				n = size
-			}
-			dowrite(w, hostlink_buf, n)
-			size -= n
-		}
+		if _, err := io.CopyN(w, f, int64(h.len)); err != nil {
+			Ctxt.Cursym = nil
+			Diag("cannot copy %s: %v", p, err)
+			Errorexit()
+		}

-		if obj.Close(w) < 0 {
+		if err := w.Close(); err != nil {
			Ctxt.Cursym = nil
			Diag("cannot write %s: %v", p, err)
			Errorexit()
		}

-		obj.Bterm(f)
+		f.Close()
}
diff {
-	cout = new(obj.Biobuf)
-	obj.Binit(cout, coutfd, obj.OWRITE)
+	cout = obj.Binitw(coutfd)
}
diff {
-	obj.Close(coutfd)
+	coutfd.Close()
	p = fmt.Sprintf("%s/go.o", tmpdir)
-	coutfd = obj.Create(p, 1, 0775)
-	if coutfd < 0 {
+	var err error
+	coutfd, err = os.Create(p)
+	if err != nil {
}
diff {
-	if len(hostobj) >= cap(hostobj) {
-		if cap(hostobj) == 0 {
-			cap(hostobj) = 16
-		} else {
-			cap(hostobj) *= 2
-		}
-		hostobj = obj.Erealloc(hostobj, cap(hostobj)*sizeof(hostobj[0])).([]Hostobj)
-	}
-
-	h = &hostobj[len(hostobj)]
-	len(hostobj)++
+	hostobj = append(hostobj, Hostobj{})
+	h = &hostobj[len(hostobj)-1]
}

bool ldhostobj.isinternal
bool externalobj

diff {
-var coutfd int = -1
+var coutfd *os.File
}
diff {
-if coutfd >= 0 {
+if coutfd != nil {
}

diff {
-	f = obj.Bopenr(file)
-	if f == nil {
+	var err error
+	f, err = obj.Bopenr(file)
+	if err != nil {
}

diff {
-var ARMAG string = "!<arch>\n"
-
-var ARFMAG string = "`\n"
+const (
+	ARMAG = "!<arch>\n"
+	ARFMAG = "`\n"
+)
}

func nextar(bp *obj.Biobuf, off int64, a *obj.ArHdr) int64 {
	if off&1 != 0 {
		off++
	}
	obj.Bseek(bp, off, 0)

	var buf [obj.SAR_HDR]byte
	n := obj.Bread(bp, buf[:])
	if n <= 0 {
		return int64(n)
	}
	if n != obj.SAR_HDR {
		return -1
	}
	
	if string(buf[len(buf)-2:]) != obj.ARFMAG {
		return -1
	}
	
	s := string(buf[:])
	a.Name = strings.Trim(s[0:16], " ")
	a.Date = strings.Trim(s[16:28], " ")
	a.Uid = strings.Trim(s[28:34], " ")
	a.Gid = strings.Trim(s[34:40], " ")
	a.Mode = strings.Trim(s[40:48], " ")
	a.Size = strings.Trim(s[48:58], " ")
	
	size, _ := strconv.ParseInt(a.Size, 0, 64)
	if size&1 != 0 {
		size++
	}
	return obj.SAR_HDR + size
}

export ar_hdr

diff {
		off += l
-
-		l = obj.SARNAME
-		for l > 0 && arhdr.Name[l-1] == ' ' {
-			l--
-		}
-		pname = fmt.Sprintf("%s(%.*s)", file, main.Utfnlen(arhdr.Name, int(l)), arhdr.Name)
-		l = obj.Atolwhex(arhdr.Size)
+		pname = fmt.Sprintf("%s(%s)", file, arhdr.Name)
+		l, _ = strconv.ParseInt(arhdr.Size, 0, 64)
}

diff {
	if Debug['u'] != 0 {
-		ldpkg(f, pkg, obj.Atolwhex(arhdr.Size), file, Pkgdef)
+		n, _ := strconv.ParseInt(arhdr.Size, 0, 64)
+		ldpkg(f, pkg, n, file, Pkgdef)
	}
}

diff {
-	var st struct {
-		st_mode int
-	}
-	if main.Lstat(outfile, &st) == 0 && !(main.S_ISREG(st.st_mode) != 0) {
-		return
-	}
-
+	f, err := os.Lstat(outfile)
+	if err == nil && !f.Mode().IsRegular() {
+		return
+	}
}
diff {
-	obj.Fmtinstall('i', iconv)
-	obj.Fmtinstall('Y', Yconv)
-	obj.Fmtinstall('Z', Zconv)
}

func Lflag(arg string) {
	Ctxt.Libdir = append(Ctxt.Libdir, arg)
}

diff {
-var externalobj bool = 0
+var externalobj bool
}

diff {
-	coutfd = obj.Create(outfile, 1, 0775)
-	if coutfd < 0 {
+	var err error
+	coutfd, err = os.OpenFile(outfile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0775)
+	if err != nil {
}

diff {
	if INITENTRY == "" {
-		INITENTRY = string(make([]byte, obj.Strlen(goarch)+obj.Strlen(goos)+20))
-		if !(Flag_shared != 0) {
+		if Flag_shared == 0 {
			INITENTRY = fmt.Sprintf("_rt0_%s_%s", goarch, goos)
		} else {
			INITENTRY = fmt.Sprintf("_rt0_%s_%s_lib", goarch, goos)
		}
	}
}
diff {
	if coutfd != nil {
		// For rmtemp run at atexit time on Windows.
		obj.Bflush(cout)
-
-		obj.Close(coutfd)
+		coutfd.Close()
	}
}

bool iscgo

diff {
-		iscgo |= Ctxt.Library[i].Pkg == "runtime/cgo"
+		iscgo = iscgo || Ctxt.Library[i].Pkg == "runtime/cgo"
}

diff {
-func readsym_ldpe(peobj *PeObj, i int, y **PeSym) int {
+func readsym_ldpe(peobj *PeObj, i int, y **PeSym) error {
}
diff {
-		obj.Werrstr("invalid pe symbol index")
-		return -1
+		return fmt.Errorf("invalid pe symbol index")
}
diff {
-		obj.Werrstr("%s: invalid symbol type %d", sym.name, sym.type_)
-		return -1
+		return fmt.Errorf("%s: invalid symbol type %d", sym.name, sym.type_)
}
diff {
-			obj.Werrstr("%s: invalid symbol binding %d", sym.name, sym.sclass)
-			return -1
+			return fmt.Errorf("%s: invalid symbol binding %d", sym.name, sym.sclass)
}
diff {
		s.Got = -2 // flag for __imp_
	}
	sym.sym = s

-	return 0
+	return nil
}
diff {
	// remove last @XXX
-	p = obj.Strchr(name, '@')
-
-	if p != "" {
-		p = ""
-	}
+	if i := strings.Index(name, "@"); i >= 0 {
+		name = name[:i]
+	}
}
diff {
-
		name = sym.name
-		if strings.HasPrefix(name, "__imp_") {
-			name = string(&name[6]) // __imp_Name => Name
-		}
+		name = strings.TrimPrefix(name, "__imp_")
-		if Thearch.Thechar == '8' && name[0] == '_' {
-			name = string(&name[1]) // _Name => Name
-		}
+		if Thearch.Thechar == '8' {
+			name = strings.TrimPrefix(name, "_")
+		}
}

bool issect.return

diff {
-			if readsym_ldpe(peobj, int(symindex), &sym) < 0 {
+			if err = readsym_ldpe(peobj, int(symindex), &sym); err != nil {
}

diff {
-		if readsym_ldpe(peobj, i, &sym) < 0 {
+		if err = readsym_ldpe(peobj, i, &sym); err != nil {
}

diff {
func ldpe(f *obj.Biobuf, pkg string, size int64, pn string) {
+	var err error
}

diff {
-				obj.Werrstr("reloc of invalid sym %s idx=%d type=%d", sym.name, symindex, sym.type_)
+				err = fmt.Errorf("reloc of invalid sym %s idx=%d type=%d", sym.name, symindex, sym.type_)
				goto bad
}
diff {
-			obj.Werrstr("unexpected flags %#06x for PE section %s", sect.sh.Characteristics, sect.name)
+			err = fmt.Errorf("unexpected flags %#06x for PE section %s", sect.sh.Characteristics, sect.name)
			goto bad
}

func map__ldpe(peobj *PeObj, sect *PeSect) error {
	if sect.base != nil {
		return nil
	}

	sect.base = make([]byte, sect.sh.SizeOfRawData)
	if sect.sh.PointerToRawData == 0 { // .bss doesn't have data in object file
		return nil
	}
	obj.Bseek(peobj.f, int64(peobj.base)+int64(sect.sh.PointerToRawData), 0)
	if n, err := io.ReadFull(peobj.f, sect.base); err != nil {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
		return err
	}

	return nil
}

slice Pkg.impby Pkg.nimpby Pkg.mimpby
export expandpkg

diff {
-		if map__ldpe(peobj, sect) < 0 {
+		if err = map__ldpe(peobj, sect); err != nil {
}

slice PeObj.snames
slice PeObj.sect PeObj.nsect
slice PeObj.pesym PeObj.npesym
